1 -> No type for variables(not even let)

2 -> ** is operator used for exponentiation

3 -> ruby does not have i++ or i-- operators. We have to use  i+= 1 etc..

4 -> 0..42 creates a collection(array) from 0 to 42
     But to convert it to an array we have to call .to_a

5 -> For a method that expects a block/method, we can pass in built in method. 
     All elements will be implicitly passed to that method.
     e.g .select(&:even?) OR .map(&:to_i)

6 -> %w(The quick brown fox jumped over the lazy dog).
     Ruby converts each word inside the () into a seperate element in an array(words are WITHOUT quotes)

8 -> we can use .to_i to convert an element to an integer.

9 -> [a..g] can be used to get an array of alphabets from a through g

10 -> If we multiply a string, it will duplicate itself to the number of times.

11 -> irb or "the ruby shell" for running ruby code. Simpley type irb 

12 -> In ruby, everything is an Object.

13 -> 10.times, runs a loop for ten times

14 -> sleep 10, is equivalent to setTimeout

15 -> We can have multiple classess in a single file.

16 -> We can check if a method exists on an object by doing obj.respont_to?(:method_name)

17 -> We can put _ where we usually put , to easy readability.
      e.g 2_000_000

18 -> We can use prime module of ruby to deal with prime numbers

19 -> We can use date module of ruby to deal with dates

Printing:
   -> puts "" OR puts [1, 2, 3]     // returns null i.e just printing but also iterates if iteratable
   -> p "" OR p [1, 2, 3]           // Here p prints and returns the value


Getting value:
   -> gets 
   -> gets.chomp()                  // truncates the \n character in the end


Variables:
   -> Local Variables

   -> Global variables
         -> put $ infront of the variable (e.g $x)
         -> Highly not recommended to use it as it will pollute the code and cause unnecessary naming issues.

   -> Instance variables
         -> put @ infront of the variable (e.g @y)
         -> Used to share data across components like from method to a view etc..

   -> Constant
         -> All caps. Also, its value can be changed.

   -> Class variable
         -> put @@y infront of the variable (e.g @@z)
         -> Varibale only available to that class instance.

Strings:
   -> Interpolation #{variable}
   -> Diff between '' and "" is, if '' is used, all text inside is considered as plain string
      i.e No dynamic values. So, need to use "" for String Interpolation

Numbers:
   -> Integers
   -> Float (very small decimal places)
   -> Decimals (very accurate decimal places and takes more space)

Methods:
   -> method name and also parameters should be in snake case
   -> Syntax: 
      def method_name(first, last)
         // body
      end
   -> We can execute methods by just calling method name without ()
   -> The return value is whatever is there in the last line and it is considered bad practice to 
      explicitly use return keyword.
   -> Inside of a class, we can use def self.method_1 to create a class method. If normal syntax is used,
      then it is an instance method 
   -> The () can be skipped for a method both while calling and also while definfing actual params for a method.
      e.g my_method first_name last_name
          my_method "Musheer", "Ahamed"
   -> We can use named arguments to explicitly define which arguments we are passing to the function(avoid unnecessary delay).
      e.g my_method first:, second:
          my_method second: "Ahamed", first: "Musheer" 
   -> Default value to a method param can be done using `def my_method first_name:, last_name: "Ahamed"`
      or if variable passed(named params) and used is different, then ( name: my_name = "Musheer" )      // here name is the named param passed to this method
      As we have to use name: in this case. So, if we have to pass in some value, we have to consider it as named param and explicitly use the param name.
   -> Splat 
         -> lets us pass in multiple arguments but treats them as a regular array inside of the method
            *my_name
         -> A method canâ€™t have two parameters with splat operator
         -> A local variable will reference an empty array if arguments are not passed
         -> It can be placed anywhere in the parameter list. It will take arguments accordingly giving precedence to other params
            i.e first, *splat, last and we pass in four arrgs. splat will take the middle two etc..
         -> We can flatten arrays using splat. This is the opposite of its use case in method parameters
            This can be used while passing arguments to a method that expects multiple params
            e.g new_arr = [*array1, 4, 5, *array2] OR new_arr = *array1, 4, 5, *array2
            e.g my_method *array1
         -> We can also array coercion(i.e convert anything to an array)
            e.g 
               *1..10            -> [1, 2, .... 10]
               *"Hello"          -> ["Hello"]
                *[1,2,3]         -> [1,2,3]                 // no changes
               *{ a: "Hello" }   -> an array [[:a, "Hello"]]
         -> can also be used in multiple variable assignment.(see below)
   -> Keyword value Splat(double Splat)
         -> This can be used to pass in key value pairs(JSON data).
            **my_name
         -> We can also double splat while calling methods to pass JSON data. This will flattened to the appropriate fields
            the method expects(Opposite of above use case). Here JSON data is flattened to named method params which method expects
   -> Optional arguments can be used to pass in arguments as named fields but received as an object.
      It is same as Keyword value splat, except that the data passed will be named fields instead of a JSON data.
      e.g def my_func options={}
            options[:company]
         end
   -> When using terinary operator, we should use () if we calling any method that returns a boolean
   Types of Encapsulation:
      -> private:
            Syntax:
               private 
                  def my_method
                     // code
                  end
      -> public:
         -> This is the default. No need to mention anything
      
      -> protected:
         -> This is almost similar to private, but with few small differences

   Closure:
      -> A closure is a function that: 
            -> Can be passed around as a variable.
            -> Binds to the same scope in which it was created.
            -> To different extents, code blocks, procs, and lambdas can be seen as closures.
      -> Construction
            -> { |arg| } 
            -> do |arg| end
      -> Both the above snippets are considered as code blocks. If in a single line we use {} else do end.

   Procs:
      -> A proc is an object that contains a code block. It provides a way to save up a code block and execute it later.
      -> Proc objects are bound to a set of local variables(NOT arguments but like closure). 
      -> Proc can have one, none or many arguments
      -> Construction
            -> Proc.new { |arg| } OR Proc.new do |arg| end
            -> proc { |arg| } OR proc  do |arg| end
      -> Calling
            -> my_proc["first", "second"]
            -> my_proc.call("first", "second")
      -> The arguments passed may not be same as declared.
      -> If we use return keyword in a Proc, it not only returns from the Proc block, but also from the exclosed function
         (i.e no code beneath after calling Proc will get executed).

   Lambda:
      -> The symbol for stabby lambda is ->
      -> Construction
            -> lambda {|arg| } OR proc  do |arg| end
            -> -> (arg) { } OR proc  do end      // stabby lambda
      -> The arguments passed MUST be same as when declared.
            
      Notes:
         -> Only -> (stabby lambda) takes argument outside of code block
            e.g -> (arg) { puts arg }

Class:
   -> We can create a class variables and also set getters and setters in a single line
      e.g attr_accessor :title, :name, :url 
   -> Creating instance 
      MyClass.new
   -> initializer method. 
      def initialize
   -> We can also execute some code inside of a class. Not just declaring variables and methods

   Syntax:
      class MyClass
         // code
      end

   Inheritence;
      Syntax:
         class ChildClass < BaseClass

   Polymorphism:
      -> We can just call super(NOT super.my_method) inside of a method. It will automatically call the super class method.

Loops:
   -> while
      Syntax:
         while i < 10
            // code
         end     
   -> Iterating arrays
      Syntax:
         my_array.each CODE_BLOCK 
   -> for in Loops
      Syntax:
         for i in my_array
            // code 
         end
   -> We can create an infinite loop using the syntax
      loop do
         // code
         // break
      end 
   
Conditionals:
   -> If else conditional
      -> Syntax
         1. 
            if x == y 
               // code
            elsif x > y             // YES ELSIF
               // code
            else
               // code
            end
         2. To put things in a single line
               puts "something" if a > b?
   -> unless conditional
      -> same as the opposide of if. can be used for more readability
      Syntax
      1. 
         unless a > b?
            // code
         end
      2. To put things in a single line
         puts "something" unless a > b?


Symbol:
   -> A symbol is a uniq instance of the Symbol class which is generally used for identifying a specific resource. 
   -> A Symbol object is created by prefixing an operator, string, variable, constant, method, class, module name(anything)
      with a colon.
      We can also create a symbol without any of the above. e.g :dummy_symbol. This is used in hash objects
   -> A symbol looks like a variable name but it's prefixed with a colon.
   -> It's just a name and an internal ID(i.e since each symbol has to be unique it is assigned an internal id). 
      e.g :Test.object_id.to_s 
   -> Symbol Object don't contain values or objects, like variables do. Instead they refer to some unique id.
      e.g class Test. Here, Test is a class Variable, but :Test is a symbol.
      Even in case of symbols used as fields in hash obj, we can cnsider that as a variable and its own symbol.
   IMPORTANT
   -> They're used as a consistent name/value within code(when used as values). Also this is more effecient than Strnigs.
      e.g know_ruby = :yes
   -> Symbols are more efficient than strings. Two strings with the same contents are two different objects,
      but for any given name there is only one Symbol object. 
   -> Ruby uses symbols, and maintains a Symbol Table to hold them. We can get all Symbols using Symbol.all_symbols. 
   -> A new symbol is created when we define
         -> a new symbol(explicit)
         -> a new variable
         -> a new method
         -> a new class/module
   -> The symbol object will be unique for each different name but does not refer to a particular instance of the name.
      i.e if the same symbol is used in code to assign to different objects, the symbol obj will be same, but its actual 
      type will be different according to the context in which it is used.

Collections:

Arrays:
   -> We can create using [1, 2] OR Array.new
   -> It may contain values of different types in the same array
   -> we can use arr[index] = "value" to insert value at a certain index. But, all unfilled indexes before it will be filled as nil. 
   -> We can also push elements using array << 10  // other than array.push() 
   -> we can delete using .delete, .delete_at, .delete_if
   -> We can remove certain elements from an array using 
      [1, 2, 2, 3, 4] - [2, 4]     // removes all elements with 2 and 4
      Same for adding / merging
      [1, 2, 2, 3, 4] + [5, 6]
   -> We can splice easily using array[1..array.length] i.e array[start..end]
      Also, array[1..array.length-1]   // doing arithmetic in end value

Hash:
   -> If we need to use symbol, we can either do :my_symbol => "Hellow" OR my_symbol: "Hello"
      We don't need : for string keys(i.e inside ""), 
      We need to use Hash Rocket(=>) for all cases other than symbols(modern syntax e.g my_symbol: "value").
      we cannot use number as symbols(i.e 1: "One" won't work, but can be used as 1 => "One")
   -> We can set override default value(nil) using 
         -> Hash.new( "month" ) OR Hash.new "month"
         -> my_hash = Hash.new; my_hash.default = "Hello" 
   -> We can also create fields dynamically(i.e after initial hash object creation). my_hash[:my_new_symbol] = "Value"
   -> A user-defined class may be used as a hash key if the hash and eql? methods
      are overridden to provide meaningful behavior
   -> A has can be visualized as an array like a whole array with each key value being a nested array within it
      e.g [[:a, "Hello"], [:b, "World"]] equivalent to { a: "Hello", b: "World" }
   -> Fetching values. my_hash[:my_symbol]   i.e my_hash['my_symbol'] will not work here, it will work only for Strings.
   -> Deleting value. my_hash.delete(:my_symbol)
   -> Syntax:
         Hash.new
         Hash["a", 100, "b", 200]                  #=> {"a"=>100, "b"=>200}
         Hash[ [ ["a", 100], ["b", 200] ] ]  (array of key value pairs(array of arrays))      #=> {"a"=>100, "b"=>200}
         Hash["a" => 100, "b" => 200]              #=> {"a"=>100, "b"=>200}
         { :one => "eins", :two => "zwei", :three => "drei" }
         { one: "eins", two: "zwei", three: "drei" }
      Default values:
         Hash.new( "month" ) OR Hash.new "month"            // default value when key does not exist
         OR 
         Hash.new { |hash, key| hash[key] = "Go Fish: #{key}" }
   Notes:
      -> The [ next to Hash MUST be close to it(e.g Hash[] and not Hash []). Otherwise it will throw error.

Dates:
   -> We can iterate over dates just like collection

Files:
   -> File.open("path_from_root", "option") { | f | f.write("Something")}
      OR
      File.new("path_from_root", "option")
   -> Reading
      File.read("path_from_root")
   -> File.delete("path_from_root")
   -> Appending to a file
      File.open("path_from_root", "a") { | f | f.puts("Something")}
   -> Need to close after using it(except while using a block in case 1).
      Options:
         -> r  - reading
         -> a  - appending to a File
         -> w  - just writing
         -> w+ - reading and writing
         -> a+ - Open a file for reading and appending
         -> r+ - Open a file for updating, both reading and writing

Error Handling:
   -> Syntax:
         begin
            // code
         rescue
            // code
         end

         Rescue specific errors:
         begin
            // code
         rescue StandardError => e
            // code
         end
   -> Inside of the rescue method, we can call our own method to build our own custom error logger.

Regular expression:
   -> Syntax:
      /[a-d]/
   -> /[a-d]/i for case incensetive matcher
   -> We can do v ~= /[abcde]/ to do pattern matching. 
   -> We can rubular.com to test regex

Grep:
   -> Grep used for searching arrays and collections.

Meta programming:
   -> We can open up classess(Both core and custom classes) to customize class.
   -> Typical spot for definfing meta programming is the initializers.
   -> Method missing:
         -> We can use method_missing method provided by ruby to execute a method if not already available.
         -> It is considered a best practice to also implement the respond_to_missing?, so that the respond_to on the
            new function returns true. i.e the method exists on the object.
         -> Method is not created in this case, but before throwing NoMethodFoundError, ruby gives us the option of executing some code.
   
   -> Defining method(runtime):
         -> We can use the define_method to actually creates method at runtime.
         -> In this case, the respond_to on that method will also be true.(i.e no need to implement seperately like method_missing)
         -> This can be used to create multiple methods which share the same code
            e.g 
            my_array.each do |method_name|
               define_method("#{method_name}_action") do | args |
                  // code
               end
            end 

Algorithms:
   -> Ruby uses quicksort algo for sorting

Multiple Variable Assignment:
   -> x, y = y, x
   -> x, y = [1, 2]        // Array destructuring
   -> We can swap elements in an array by just doing
      a[i], a[i+1] = a[i+1], a[i]
   -> Using splat, first, *second = ["a", "b", "c", "d", "e"]
      OR first, *, last = ["a", "b", "c", "d", "e"]      // if we only want the first and last elem.
      OR first, * =  ["a", "b", "c", "d", "e"]      // if we only want the first elem.

Bang operator and ! in methods
   -> The bang operator can also be called on a variable like any other method call, arr.! .
      This would return the same value as !arr.
   -> Bangs are used to say this is the more unusual version of the method(e.g Mutating and error throwing).
      .! coerces data to return a boolean value that is opposite to the truthiness or falsness that Ruby assigns to that data type
      Any methods that end in an ! may mutate the data that is the method is called on.
      Also used for methods that raise an exception when the method without it does not(i.e returns boolean normally).

Ruby gems:
   -> We can definfe - group: development to say that a gem needs to be run only in development. 
   -> Rails itself is a ruby gem
   -> For requiring a ruby gem, first require 'rubygems', then the gem we want to require
   -> Sample gems
         Device gem     - used for registration, sign-in, sign out. Related to authentication
         Will_paginate  - pagination
         Honey badger   - For issue management (like pager duty)
         New relic  rpm - For perf tracking
         Rails admin    - For admin management
         Pundit         - For handling permissions 
         Breakman       - finding security issues. 
         Web framework  - Sinatra
         HttpParty      - Making Http calls
