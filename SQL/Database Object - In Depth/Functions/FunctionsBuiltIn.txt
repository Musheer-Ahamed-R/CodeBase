In-Built Functions -
      ISNULL         -     -> If the Expression passed is NOT NULL, then the Expression value itself is Returned, else the second Argument is Returned.
                           Syntax :
                              ISNULL(Expression, replacementValue)
                           Compatibility :
                              SQLSever

      COALESCE      -     -> Evaluates the arguments in order and returns the current value of the first expression that initially does not evaluate to NULL.
                          -> The COALESCE Expression is a syntactic shortcut for the CASE Expression. That is, the code COALESCE(expression1,...n) is rewritten by the query optimizer as the following CASE expression:
                             CASE
                              WHEN (expression1 IS NOT NULL) THEN expression1
                              WHEN (expression2 IS NOT NULL) THEN expression2
                              ...
                              ELSE expressionN
                             END
                          Syntax :
                              COALESCE ( expression [ ,...n ] )
                          Compatibility :
                              SQLServer, PostgreSQL

      GREATEST      -     -> The GREATEST functions select the largest value from a list of any number of expressions. The expressions must all be convertible to a common data type, which will be the type of the result.
                             NULL values in the list are ignored. The result will be NULL only if all the expressions evaluate to NULL.
                             Syntax :
                                 GREATEST(value [, ...])
                             Compatibility :
                                 PostgreSQL

      LEAST         -     -> The LEAST functions select the smallest value from a list of any number of expressions. The expressions must all be convertible to a common data type, which will be the type of the result.
                             NULL values in the list are ignored. The result will be NULL only if all the expressions evaluate to NULL.
                             Syntax :
                                 LEAST(value [, ...])
                             Compatibility :
                                 PostgreSQL

      NULLIF        -     -> The NULLIF function returns a null value if value1 equals value2; otherwise it returns value1. This can be used to perform the inverse operation of the COALESCE.
                             Syntax :
                                 NULLIF(value1, value2)
                             Compatibility :
                                 PostgreSQL

      ASCII         -     -> Returns the ASCII Code of the Given Character Expression.
                             Syntax
                                 ASCII(Character_Expression)
                             Compatibility :
                                 SQLServer

      CHAR          -     -> Converts an Int ASCII Code to a Character Expression(Reverse of ASCII function).
                             Syntax
                                 CHAR(Integer_Expression)
                             Compatibility :
                                 SQLServer

      LTRIM         -     -> Removes Blanks on the Left hand-side of the Character Expression.
                             Syntax
                                 LTRIM(Character_Expression)
                             Compatibility :
                                 SQLServer

      RTRIM         -     -> Removes Blanks on the Right hand-side of the Character Expression.
                             Syntax
                                 RTRIM(Character_Expression)
                             Compatibility :
                                 SQLServer

      LOWER        -     -> Converts all the Character in the given Character Expression to LowerCase Letters.
                            Syntax
                                 LOWER(Character_Expression)
                            Compatibility :
                                 SQLServer

      UPPER        -     -> Converts all the Character in the given Character Expression to UpperCase Letters.
                            Syntax
                                 UPPER(Character_Expression)
                            Compatibility :
                                 SQLServer

      REVERSE      -     -> Reverses all the Character in the given String Expression.
                            Syntax
                                 REVERSE(String_Expression)
                            Compatibility :
                                 SQLServer

      LEN          -     -> Returns the Count of Total Characters in the given String Expression excluding the Blanks at the End of the Expression.
                            Syntax
                                 LEN(String_Expression)
                            Compatibility :
                                 SQLServer

      LEFT         -     -> Returns the Specified Number of Characters from the Left hand Side of the Given Character Expression.
                            Syntax
                                 LEFT(Character_Expression, Integer_Expression)
                            Compatibility :
                                 SQLServer

      RIGHT        -     -> Returns the Specified Number of Characters from the Right hand Side of the Given Character Expression.
                            Syntax
                                 RIGHT(Character_Expression, Integer_Expression)
                            Compatibility :
                                 SQLServer

      CHARINDEX    -     -> Returns the Starting position of the Specified Expression in a Character String.
                            Syntax
                                 CHARINDEX(Expression_to_Find, Expression_to_Search, Start_Location)
                            Compatibility :
                                 SQLServer

      SUBSTRING    -     -> Returns the SubString from the Given Character String.
                            Syntax
                                 SUBSTRING(Expression, Start_Location, length)
                            Compatibility :
                                 SQLServer

      REPLICATE    -      -> Repeats the Given String for the Specified Number of Times.
                             Syntax
                                 Replicate(String_To_Be_Replicated, Number_of_Times)
                             Compatibility :
                                 SQLServer

      SPACE        -      -> Returns the Specified Number of Spaces.
                             Syntax
                                 SPACE(Number_of_Times)
                             Compatibility :
                                 SQLServer

      PATINDEX     -      -> Returns the Starting Position of the First Occurrence of a Pattern in a Specified Expression.
                          -> With CharIndex, we cannot use Wildcards, whereas PatIndex() providers this Capability.
                             Syntax
                                 PATINDEX(Pattern_To_Be_Searched, Expression)
                             Compatibility :
                                 SQLServer

      REPLACE      -      -> Replaces all Occurrences of a Specified value with another String Value.
                             Syntax
                                 REPLACE(String_Expression, Pattern, Replacement_Value)
                             Compatibility :
                                 SQLServer

      STUFF        -      -> Inserts Replacement_Expression, at the Start Position Specified, along with removing the Characters Specified using length parameter.
                             Syntax
                                 STUFF(Original_Expression, Start, Length, Replacement_Expression)
                             Compatibility :
                                 SQLServer

      ISDATE       -      -> Checks if the given Value is a Valid Date, Time or DataTime.
                             Syntax
                                 ISDATE(String_Expression)
                             Compatibility :
                                 SQLServer

      DAY          -      -> Returns the "Day Number of the Month" of the Given Date.
                             Syntax
                                 DAY(String_Expression)
                             Compatibility :
                                 SQLServer

      MONTH        -      -> Returns the "Month Number of the Year" of the Given Date.
                             Syntax
                                 MONTH(String_Expression)
                             Compatibility :
                                 SQLServer

      YEAR         -      -> Returns the "Year Number" of the Given Date.
                          Syntax
                              YEAR(String_Expression)
                          Compatibility :
                              SQLServer

      DATENAME     -      -> Returns a String, that represents a Part of the Given Date.
                          -> Date_Part can take WEEKDAY, DAY, MONTH, YEAR etc..
                          Syntax
                              DATENAME(Date_Part, Date)
                          Compatibility :
                              SQLServer

      DATEPART     -      -> Returns a integer, that represents a Part of the Given Date.
                          -> Date_Part can take WEEKDAY, DAY, MONTH, YEAR etc..
                          -> This is Similar to DateName. DateName returns nvarhcar whereas DATEPART Integer.
                          Syntax
                              DATEPART(Date_Part, Date)
                          Compatibility :
                              SQLServer

      DATEADD      -      -> Returns a integer after adding the Specified Number to the DATEPART(value that represents a Part of the Given Date).
                          -> Date_Part can take WEEKDAY, DAY, MONTH, YEAR etc..
                          Syntax
                              DATEADD(Date_Part, numberToAdd, Date)
                          Compatibility :
                              SQLServer

      DATEDIFF     -      -> Returns the Count of the Specified DATEPART boundaries crossed between the Specified Start Date and the End Date.
                          -> Date_Part can take WEEKDAY, DAY, MONTH, YEAR etc..
                          Syntax
                              DATEDIFF(Date_Part, startDate, endDate)
                          Compatibility :
                              SQLServer

       CAST        -      -> Converts one Datatype to Other Data Type. Provided the Data can be Converted to the Other Data Type.
                          Syntax :
                               CAST ( expression AS data_type [ ( length ) ] )
                          Compatibility :
                               SQLServer
                          Note -
                            -> Value can be a Column.

      CONVERT      -      -> Converts one Datatype to Other Data Type. Provided the Data can be Converted to the Other Data Type.
                          -> Using this Function, we can Style our Date Output(Not Available in CAST))
                          Syntax :
                               CONVERT ( data_type [ ( length ) ] , expression [ , style ] )
                          Compatibility :
                               SQLServer

      ABS          -      -> This Returns the Absolute Positive Number.
                          Syntax
                              ABS(Numeric_Expression)

      CEILING      -      -> This returns the Smallest Integer Value, greater than or equal to the Parameter.
                          Syntax
                              CEILING(Numeric_Expression)

      FLOOR        -      -> This returns the Largest Integer Value, less than or equal to the Parameter.
                          Syntax
                              FLOOR(Numeric_Expression)

      POWER        -      -> This returns the Power value of the Specified Expression to the Specified Power.
                          Syntax
                              POWER(Numeric_Expression, toPower)

      SQUARE       -      -> This returns the Square value of the Specified Expression.
                          Syntax
                              SQUARE(Numeric_Expression)

      SQRT         -      -> This returns the Square Root value of the Specified Expression.
                          Syntax
                              SQRT(Numeric_Expression)

      RAND         -      -> This returns a Random Float Number between o and 1.
                          -> When the Seed value is Specified, the Random function always returns the Same Value for the Same Seed.
                          Syntax
                              RAND( [Seed_Value] )

      ROUND         -     -> Rounds the given Numeric Expression based on the length. This returns a Random Float Number between o and 1.
                          -> When the Seed value is Specified, the Random function always returns the Same Value for the Same Seed.
                          Syntax
                              ROUND( Numeric_Expression, length [, function] )

                           Notes :
                              -> length   - Specifies the Number of Digits that we want to round to. If the Length is positive, then the Rounding
                                            is applied to the Decimal Part. If negative, then the Rounding is applied to the Number before Decimal.
                                 function - It is used to Indicate Rounding or Truncating Operation. 0 - Rounding(default) and 1 - Truncating.


Aggregate Functions -     -> The Function is applied to the whole Group,
                           but we can use a Condition(Corresponding to every Single Row in the GROUP) to determine whether to pass an expression(to be included in the result) or Not as an Argument to the Function
                           Expression  can be Column Expression or a Condition(on Every Single Row of the Group) that returns an Expression or Some Constant).
                           Selected Group.(e.g Condition - DISTINCT, CASE(returning 1 or 0) OR ANY NORMAL CONDITION ON ANY NUMBER OF COLUMNS that returns an EXPRESSION... )                   -------- IMPORTANT   ------------

User-Defined Functions  -> SQL Server user-defined functions are routines that accept parameters, perform an action, such as a complex calculation, and return the result of that action as a value.
                           The return value can either be a single scalar value or a result set(TVF).
                        -> Limitations and restrictions
                              -> User-defined functions cannot contain an OUTPUT INTO clause that has a table as its target.
                              -> User-defined functions can not return multiple result sets. Use a stored procedure if you need to return multiple result sets.
                              -> Error handling is restricted in a user-defined function. A UDF does not support TRY…CATCH, @ERROR or RAISERROR.
                              -> User-defined functions cannot call a stored procedure, but can call an extended stored procedure.
                              -> User-defined functions cannot make use of dynamic SQL or temp tables. Table variables are allowed.
                              -> SET statements are not allowed in a user-defined function.
                             *-> User-defined functions CANNOT be used to perform actions that MODIFY the Database state(NO DML QUERIES).
                                 Because a function may not have side effects (change the permanent database structure), the optimiser is free to run it as many times as makes sense for a query plan.
                                 If it had side effects (eg creating a temp table) then if the optimizer chose a different plan the results would be different and that is not permitted.
                              -> Frameworks such as ADO.NET, etc. can't call a function directly, but they can call a stored proc directly. Stored procs are used to bind SQL queries together in a transaction,
                                 and interface with the Outside world.
                             *-> At runtime Views and Inline TVFs are both inlined and treated similarly to derived tables or CTEs.
                                 Views
                                    Accepts Parameters               - No
                                    Expanded out by Optimiser        - Yes
                                    Can be Materialized in advance   - Yes (through indexed views)
                                    Is Updatable                     - Yes
                                    Can contain Multiple Statements  - No
                                    Can have triggers                - Yes
                                    Can use side-effecting operator  - Yes

                                 Inline TVFs
                                    Accepts Parameters               - Yes
                                    Expanded out by Optimiser        - Yes
                                    Can be Materialized in advance   - No
                                    Is Updatable                     - Yes
                                    Can contain Multiple Statements  - No
                                    Can have triggers                - No
                                    Can use side-effecting operator  - No

                                 MultiStatement TVFs
                                    Accepts Parameters               - Yes
                                    Expanded out by Optimiser        - No
                                    Can be Materialized in advance   - No
                                    Is Updatable                     - No
                                    Can contain Multiple Statements  - Yes
                                    Can have triggers                - No
                                    Can use side-effecting operator  - No


                              +---------------------------------+----------------------------------------+
                              | Stored Procedure (SP)           | Function (UDF - User Defined           |
                              |                                 | Function)                              |
                              +---------------------------------+----------------------------------------+
                              | SP can return zero , single or  | Function must return a single value    |
                              | multiple values.                | (which may be a scalar or a table).    |
                              +---------------------------------+----------------------------------------+
                              | We can use transaction in SP.   | We can't use transaction in UDF.       |
                              +---------------------------------+----------------------------------------+
                              | SP can have input/output        | Only input parameter.                  |
                              | parameter.                      |                                        |
                              +---------------------------------+----------------------------------------+
                              | We can call function from SP.   | We can't call SP from function.        |
                              +---------------------------------+----------------------------------------+
                              | We can't use SP in SELECT/      | We can use UDF in SELECT/ WHERE/       |
                              | WHERE/ HAVING statement.        | HAVING statement.                      |
                              +---------------------------------+----------------------------------------+
                              | We can use exception handling   | We can't use Try-Catch block in UDF.   |
                              | using Try-Catch block in SP.    |                                        |
                              +---------------------------------+----------------------------------------+

                        Advantages  -  -> They allow faster execution. Similar to stored procedures, Transact-SQL user-defined functions reduce the compilation cost of Transact-SQL code by caching the plans
                                          and reusing them for repeated executions.
                                       -> CLR functions offer significant performance advantage over Transact-SQL functions for computational tasks, string manipulation, and business logic.
                                          Transact-SQL functions are better suited for data-access intensive logic.
                                       -> They can reduce network traffic.
                        Types       -  -> Scalar Function   -  -> User-defined scalar functions return a SINGLE data value of the type defined in the RETURNS clause.
                                                               -> This consists of Two Types :
                                                                     -> Inline Scalar function
                                                                     -> Multi-Statement Scalar function
                                                               -> For an inline scalar function, there is no function body. The scalar value is the result of a single statement.
                                                               -> For a multi-statement scalar function, the function body, defined in a BEGIN...END block, contains a series of Transact-SQL statements that return the single value.
                                                               -> They can be USED IN SELECT OR WHERE CLAUSE.
                                                               -> The return type can be any data type EXCEPT text, ntext, image, cursor, and timestamp
                                                               Syntax
                                                                  CREATE [ OR ALTER ] FUNCTION [ schema_name. ] function_name
                                                                  ( [ { @parameter_name [ AS ][ type_schema_name. ] parameter_data_type
                                                                  [ = default ] [ READONLY ] }
                                                                  [ ,...n ]
                                                                  ]
                                                                  )
                                                                  RETURNS return_data_type
                                                                  [ WITH <function_option> [ ,...n ] ]
                                                                  [ AS ]
                                                                  BEGIN
                                                                       function_body
                                                                       RETURN scalar_expression
                                                                  END
                                                                  [ ; ]

                                       -> Table-Valued      -  -> User-defined table-valued functions return a table data type.
                                          Functions            -> The Table returned by the TVF, can be used JUST LIKE A TABLE(i.e Can be Used anywhere a Table can be Used).
                                                               -> This consists of Two Types :
                                                                     -> Inline Table-valued function
                                                                     -> Multi-Statement Table-valued function

                                                                     -> Inline Table-valued function  -  -> For an inline table-valued function, there is no function body(No Begin and End); the table is the result set of a SINGLE SELECT statement
                                                                                                         -> And the Structure of the Table Returned depends/determined by the Select Statement within the Function.
                                                                                                         -> Inline Table Valued Functions are an EXCELLENT Replacement for PARAMETERIZED VIEWS.
                                                                                                         -> Inline Table Valued Functions are BETTER for Performance, because statistics on the underlying tables will be used when generating an execution plan for the query.
                                                                                                         -> It is possible to Update the Underlying Table using an Inline Table Valued Functions, but not possible using Multi-Select TVF

                                                                     -> Multi-Statement TVF           -  -> Exact Opposite of Inline TVF                                       

                                                               Syntax
                                                                  -- Transact-SQL Inline Table-Valued Function Syntax
                                                                  CREATE [ OR ALTER ] FUNCTION [ schema_name. ] function_name
                                                                  ( [ { @parameter_name [ AS ] [ type_schema_name. ] parameter_data_type
                                                                  [ = default ] [ READONLY ] }
                                                                  [ ,...n ]
                                                                  ]
                                                                  )
                                                                  RETURNS TABLE
                                                                  [ WITH <function_option> [ ,...n ] ]
                                                                  [ AS ]
                                                                  RETURN [ ( ] select_stmt [ ) ]
                                                                  [ ; ]

                                                                  -- Transact-SQL Multistatement Table-valued Function Syntax
                                                                  CREATE [ OR ALTER ] FUNCTION [ schema_name. ] function_name
                                                                  ( [ { @parameter_name [ AS ] [ type_schema_name. ] parameter_data_type
                                                                      [ = default ] [READONLY] }
                                                                      [ ,...n ]
                                                                    ]
                                                                  )
                                                                  RETURNS @return_variable TABLE <table_type_definition>
                                                                      [ WITH <function_option> [ ,...n ] ]
                                                                      [ AS ]
                                                                      BEGIN
                                                                          function_body
                                                                          RETURN
                                                                      END
                                                                  [ ; ]

                                                                  -- Transact-SQL Function Clauses
                                                                  <function_option>::=
                                                                  {
                                                                      [ ENCRYPTION ]
                                                                    | [ SCHEMABINDING ]
                                                                    | [ RETURNS NULL ON NULL INPUT | CALLED ON NULL INPUT ]
                                                                    | [ EXECUTE_AS_Clause ]
                                                                  }

                                                                  <table_type_definition>:: =
                                                                  ( { <column_definition> <column_constraint>
                                                                    | <computed_column_definition> }
                                                                      [ <table_constraint> ] [ ,...n ]
                                                                  )
                                                                  <column_definition>::=
                                                                  {
                                                                      { column_name data_type }
                                                                      [ [ DEFAULT constant_expression ]
                                                                        [ COLLATE collation_name ] | [ ROWGUIDCOL ]
                                                                      ]
                                                                      | [ IDENTITY [ (seed , increment ) ] ]
                                                                      [ <column_constraint> [ ...n ] ]
                                                                  }

                                                                  <column_constraint>::=
                                                                  {
                                                                      [ NULL | NOT NULL ]
                                                                      { PRIMARY KEY | UNIQUE }
                                                                        [ CLUSTERED | NONCLUSTERED ]
                                                                        [ WITH FILLFACTOR = fillfactor
                                                                          | WITH ( < index_option > [ , ...n ] )
                                                                        [ ON { filegroup | "default" } ]
                                                                    | [ CHECK ( logical_expression ) ] [ ,...n ]
                                                                  }

                                                                  <computed_column_definition>::=
                                                                  column_name AS computed_column_expression

                                                                  <table_constraint>::=
                                                                  {
                                                                      { PRIMARY KEY | UNIQUE }
                                                                        [ CLUSTERED | NONCLUSTERED ]
                                                                        ( column_name [ ASC | DESC ] [ ,...n ] )
                                                                          [ WITH FILLFACTOR = fillfactor
                                                                          | WITH ( <index_option> [ , ...n ] )
                                                                    | [ CHECK ( logical_expression ) ] [ ,...n ]
                                                                  }

                                                                  <index_option>::=
                                                                  {
                                                                      PAD_INDEX = { ON | OFF }
                                                                    | FILLFACTOR = fillfactor
                                                                    | IGNORE_DUP_KEY = { ON | OFF }
                                                                    | STATISTICS_NORECOMPUTE = { ON | OFF }
                                                                    | ALLOW_ROW_LOCKS = { ON | OFF }
                                                                    | ALLOW_PAGE_LOCKS ={ ON | OFF }
                                                                  }

                        Notes :
                           -> Transact-SQL errors that cause a statement to be canceled and continue with the next statement in the module (such as triggers or stored procedures) are treated differently inside a function.
                              In functions, such errors cause the execution of the function to stop. This in turn causes the statement that invoked the function to be canceled.
