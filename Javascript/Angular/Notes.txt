1 -> Angular uses Typescript

2 -> Typescript is a super set of vannila JS.(i.e offers more features than vanilla JS like Classes, Interfaces and Strong typing)
		 This does not run in the browser. So, it is complied to JS in the end. This is handled by Angular CLI

3 -> We can add our own styles(Global Styles) inside of the angular.json file in styles node. 
		 If seperate module, start the path from node_modules 

4 -> index.html is the HTML file served by the server. It includes html from all the components

5 -> 

6 -> Whenever the ng serve, rebuilds the project, it will create JS bundles and automatically add the right imports in the index.html file
	 	 So the script we write in main.ts is the first things that get executed. 
		 This bootstraps/starts our angular application by passing the App module(/app/app.module.ts).
		 The app.module.ts has a bootstrap array, which lists all the components which should be known to angular
		 at the point of time it analyzes our index.html(i.e starting our server)

7 -> Angular uses Components to build web pages and uses modules to bundle different pieces(e.g Components)
     into packages.

8 -> We can create local reference(marker) on an element by using #someName within that element

9 -> We can use ng-template(inbuilt component/directive) to mark places in the DOM.

10 -> We can use Augury chrome extension to debug Angular apps. We can have a look at the state of the Application/Component etc..

11 -> Local reference are use to get access to an element in the template. They can be placed on any HTML element,
      with syntax #referenceName. This will have reference to the whole HTML element. We can use it anywhere in our template,
      but not in our typescript code(i.e need to pass in as a parameter inside of the template itself to access in TS).
      The Local reference can also be accessed using @ViewChild('localreferenceName', {static: true}) myPropertyName. Here myPropertyName has an instance of
      ElementRef (Angular obj)
      We can also get the Content of the local reference using @Content('localreferenceName', {static: true}) myPropertyName.

12 -> We can see localreference and also directives and some cases of property bindings are used with the [] in the HTML template.

12 -> Document manipulation i.e changing the element directly is highly NOT Recommended, since angular has better ways of doing it.
      i.e String Intrerpolation etc. e.g Chaging element that we have accessed through Local reference or any other means is not recommended.

13 -> Everything placed between the opening and the closing tag of our own component is lost(only takes the template within the component).
      We can change this using the Directive <ng-content>. This will serve as a hook that gets replaced by the elements
      we placed between the opening and closing tags.

14 -> It is not a good practice to directly modify elements in the Component Business logic. We can use the renderer object.
      this.rendere.setStyle(this.elementRef.nativeElement, "css-property", "value");
      Because, angular is not limited to running in the browser. This can be run in service workers, where we might not have access to the DOM.

15 -> It is better to most initializations inside of the ngOnInit func, instead of the constructor.

16 -> A component is typically destroyed when its selecector is remove from the DOM either by 
         - using the router and navigating around your app
         - when using *ngIf
         - when using *ngFor (one or more increased or decreased component).

17 -> Always don't forget. when using property binding the value inside of the "" MUST BE A TS expression.
      either the variable name or some other expression.

Components:
	1 -> There is a root component(App component) which will tie together our whole application.
	 	 We add other components to it

	2 -> Each component has its own template(HTML), styling and script

	3 -> It allows our complex application into small reusable parts

	4 -> A Component is just a TS class, so that angular is able to instantiate it.

	5 -> We add to add Decorators(Typescript feature to enhance classes and other elements) so that angular understands its not a normal class, rather a component.
		 Need to use @sign in the front (e.g @Component)
	
	6 -> We need to pass some metadata to the Decorator like selectors

	7 ->  sample component
		      @Component({
            selector: 'app-server',
            templateUrl: './app.component.html',
            styleUrls: ['./app.component.css']
          })
		      export class ServerComponent {
    		  }

          selector: The tag to be used to use this template. It works just like CSS selectors
                    (i.e selecting by element tag itself, class, attributes). Also, selecting by Id/pseudo selectors are not supported by angular. 
          templateUrl: refer to an external template
          template: Actual Html template(used if very less html code)
          styleUrls: array referring to external styles
          styles: array of CSS styling string


  8 -> We need to register the component in the app.module declarations field
       because Angular will not scan our project for all components.

  9 -> We can then use our component using the selector tag in some other main component(html file).

  9 -> We need to add the Main AppComponent in bootstrap array of app.module.
  		 This bootstrap array, lists all the components which should be known to angular
		   at the point of time it analyzes our index.html(i.e starting our server)

  11 -> Everytime we use the component selector in any template, a new component object is created.

  12 -> All properties of a component are only accessible inside of that component.
        If we want to allow parent component to be able to bind to a property, then we have to
        add a decorator to that element property. @Input('alias')

  IMPORTANT - Custom property binding
  13 -> If we need to access an object inside of a component whose data is populated by a different component, 
        then we have to define the object first and expose it to outside world using the above @input() decorator.

  IMPORTANT - Custom event trigger
  14 -> We can create a custom events and also add event listeners to them just as we add it for other inbuilt events.
        e.g Creating event and make them accessible in parent - @Output myEventName: new EventEmitter<>() 
        trigger - myEventName.emit(SOME_DATA)

  15 -> If a style is defined in a CSS file inside of a component, then it is applied to only that component. 
        The way angular achieves this behaviour is by adding unique attributes to each component 
        and associating the styles to that attribute.
        This behaviour can be changed using the field encapsulation passed to @Component() (e.g ViewEncapsulation.None)

  16 -> Lifecycle hooks
            - ngOnChanges           - Called after a bound input property changes (@Input()). Note -> This does not gets triggered if any field in the object changes!!. because it will still refer to the same object.. 
                                      This hook also passes the data of type SimpeChanges. This has prev value and new value and other details.
            - ngOnInit              - Called once the component is initialized(after constructor)
            - ngDoCheck             - Called during every change detection run
            - ngAfterContentInit    - Called after content(ng-content) has been projected into view.
            - ngAfterContentChecked - Called every time the projected content has been checked.
            - ngAfterViewInit       - Called after the component's view (and child view's) has been initialized
            - ngAfterViewChecked    - Called every time the view (and child view's) have been checked.
            - ngOnDestroy           - Called once the component is about to be destroyed. 

Databinding:
    -> Communication between TS code and the HTML template
    -> Outpu data (from TS to HTML)
        -> Types:
          -> String Interpolation {{data}}
          -> Property Binding [property]="data"
    -> React to user events (HTML to TS)
          -> (event)="expression"
    -> Two way data binding  (HTML to TS and vice versa)
          -> [(ngModel)] = 'data'

      -> String Interpolation:
            -> Within the {{ }}, we can write any Typescript expression(single line) which can resolve to a string.
               e.g referring a property, calling a function which returns a string

      -> Property Binding:
            -> Square brackets indicate to angular that we are using property binding
               e.g [disabled]="propertyName"
            -> Inside of the double quotes, we can write any TS expression same as in string interpolation
            -> we can not only bind to HTML elements but also to directives and to our own components.
            -> We can do custom property binding using the @Input('alias') fieldName. and then using ['alias'] in the outerParent Component
            -> If we pass down a string like [property]='"myString"', then we can omit both the [] of property and also the "" in the value.
               But, we have to make sure that it does not conflict with the default element property.

      -> Event Binding:
            -> On any HTMl element, we use do (event)="TS expression". The event can all the events supported for that element.
            -> Inside of the quotation marks, $event will be the date that was emitted with the event.
               Typecasting may be needed to use the data values(HTMLInputElement)

      -> Two way data binding:
            -> With this we combine property and event binding. The syntax is also combined.
            -> e.g [(ngModel)]="TS Variable", this will trigger in the input event and update the value of the variable in our component automatically.
               Also, It will update the input value if we chnage the value of variable somewhere else.


Directives:
    -> They are instructions in the DOM. (e.g Components are directives with a template 
       i.e they tell angular to use the template based on the selector)

    -> We usually add directives with an (attribute) selector, but the selector of the directive can also be like 
       the selector of a Component. 

    -> example *ngIf
          -> The * is needed is needed because ngIf is a "structural directive" because, it changes the structure of the DOM.
             i.e it either adds the element or doesn't add it(i.e Element is not hidden)
          -> The value assigned should be any expression which returns true or false. 
          -> We can also else in ngIf using markers like *ngIf="someValuse; else myMarker"

    -> ngStyle
        -> This is an "attribute directive". They don't add or remove elements rather only change the element they were placed on
        -> e.g [ngStyle]="". The square brackets here is not the directive name. The square brackets indicate 
           that we want to bind some property on this directive and the property name is also ngStyle.
        -> This expects a JS object with style name and value. The value can also be returned from a function.
        -> It allows us to dynamically update the styles.
        **** IMPORTANT ****
        -> If a variable value is changed, event if it is not directly accessed(e.g calling a function that returns that value),
           the changes will still be reflected in the DOM.
    -> ngClass
        -> This is also an "attributive directive".
        -> [ngClass]=""
        -> This expects a JS object with class name and value. The value can also be returned from a function.
        -> It allows us to dynamically update the CSS class.
    -> ngFor
        -> This is a structural directive. This is used for looping over the element
        -> *ngFor="let server of myArrayName"
        -> The let variable can be accessed directly in any TS expression, 
           but in the HTML space we have to use string interpolation to access it.
        -> let i = index, can be used to access the index of the current iteration.
        -> We cannot have more than 1 structural directive on a single element.
    -> ngSwitch
        -> Sample 
            [ngSwitch]="value"
                *ngSwitchCase="10"
                *ngSwitchDefault

            Note:
              -> No * for the initial ngSwitch

    Custom Attribute Directives:
        -> We can have our own business logic inside of a Directive and put it into any HTML element.
        -> We can inject the element the direcrtive sits on into this directive.(Angular does this).
        -> We can use @HostListener('event') funcName () {}, to listen to events automatically and also react to them(logic inside of func).
        -> We can use `@HostBinding(style.backgroundColor) myField: string` to bind a property to a TS property
           and change it in our code as a reaction to something.
        -> Sample directive:
            @Directive({
              selector: "[appHighlight]"
            })
          Note:
            -> selector is written as camelCase
            -> Need to mention the Directive in App.Module file
            -> while using the directive, we have to use it just the directive name(i.e without the [])
        -> We can bind to properties of our own directive, by simply placing them on the same element enclosed in squarebrackets.
        -> We can also have any one Main property the same name as our directive. In this case, 
            we should not mention the Directive(without square brackets), rather the property binding of the property mentioned above.

    Custom Structural directives:
        -> <*ngIf> is same as -> <ng-template [ngIf]="sampleField"> </ng-template>
        -> Sample
            @Input() set myDirName (cond: boolean) {     // This is still a property, but this gets executed when the value passed to it(input params) changes
              if (!cond) {
                this.vcRef.createEmbeddedView (this.templateRef);
              } else {
                this.vcRef.clear();
              }
            }

            constructor(private templateRef: TemplateRef, private vcRef: ViewConatainerRef) {}

            Note: 
              -> templateRef gives access to the template(ng-template - see point 1) and vcRef gives access to the view conatiner(This marks
                 the place where we place the directive in the document)
              -> Propert name should be same as Directrive name.

Services:
    -> Service is just another class, which acts a central business unit
    -> Duplication of code, data storage, providing data are typical use case of a Service
       e.g Logging service, User service(storing user data)
    -> A service can be created by just creating a class.(No decorators needed, no need to add to app.module)
    -> A service can be used in a component by adding them in the providers field in the @Component decorator and 
       using the service in the constructor.
    -> Always try to call the service functions and data from the Component TS file, rather than
       the component template itself(i.e don't attach event listeners to them directly)

Injection:
    -> Easy way to get access to some other classes, without having to instantiate them.
    -> The Angular dependency injector is actually a hierarcial injector. i.e if we provide a service for one component,
       then angular knows how to create an instance of a service to that component and also all its child component.
       i.e The Component and all its child components will receive the same instance of the Service
       i.e The Instances don't propogate Up. They only go down
    -> We can provide services at the 
          -> AppModule(whole app gets the same service instance including components and services)
          -> AppComponent - All components gets the same service instance but not the not services
          -> AnyOther Component - Same instance of the service is availabe for the Component and its child Component.

          Note:
            -> If we provide a Service instance to a child Component. It will override if we were to provide the same
               service at a higher level.
            -> To use the same service in the child component, don't add it to the providers field. 
               But have to add it to the constructor.
    -> We can inject one service into another service. For that we have to use the @Injectible decorator. 
       By this we are telling that this service can be injected. This has to be added at the receiving service.
    -> We can also make cross component communication by emitting event from the service(in one component) and
       subscribing to it in another component.
    -> In Angular6+, instead of adding a service class to the providers[]  array in AppModule. We can do
        @Injectable({providedIn: 'root'})
        export class MyService { ... }
        By this, Services can be loaded lazily by Angular (behind the scenes). 
        This can lead to a better performance and loading speed.

Router:
   -> Sample
          1. 
          Inside of app.module
          const myRoutes: Routes = [
            { path: "", component: HomeComponent },
            { path: "users", component: MySampleComponent }
          ]
          2. 
          add the RouterModule to imports in app.module
          actually, RouterModule.forRoot(myRoutes)
          3. 
          Add special directive(yes directive with element selector(usaully directives are property selectors))
          <router-outlet></router-outlet>

          Navigating Links;
            -> We have to use a special directive called routerLink=""
            -> The routerLink also supports array value - ["/users", "sample"]. Note, only first index needs to have / 
          Styling Active Router links:
            -> routerLinkActive Directive can be used to add class for an active tab.
            -> We can add it to the wrapping element or the link itself
            -> routerLinkActive="myClass".
            -> It analyzes our currently loaded path and checks which link leads to a route which uses this path.
               It then marks the element as active if it CONTAINS the path.
            -> Above creates problem for the ROOT path since all routes contain the root path. In this case we have to add
               [routerLinkActiveOptions]="{ exact: true }"
         Navigating Progmatically:
            -> We can do it using the Router from @angular/router
            -> this.router.navigate(["/servers"]);    Note, only first index needs to have /
            -> This always apppends to the root path. If relative path is needed we have to configure it as
               Add the ActivatedRoute Interface and then this.router.navigate(["/servers"], { relativeTo: this.route }); route refers to ActivatedRoute.
         Adding Dynaimc paths:
            -> While defining route. we can do "users/:myName"
            -> Inside of the loaded component, we can access the dynamic param by importing the ActivatedRoute.
               this.actRoute.snapshot.params.myName
         Passing Query Params:
            -> [queryParams]="{myKey: 'myValue'}". This is another bindable property of the routerLinkDirective
            -> Progmatically - this.router.navigate(["/servers"], { queryParams: {} });
            -> Can be accessed by this.actRoute.snapshot.queryParams and also can be subscribed for changes using
               this.actRoute.queryParams.subscribe()
         Passing Fragments(#):
            -> fragment="someValue". This is another bindable property of the routerLinkDirective
            -> Progmatically - this.router.navigate(["/servers"], { fragment: "myFragment" });
            -> Can be accessed by this.actRoute.snapshot.fragment and also can be subscribed for changes using
               this.actRoute.fragment.subscribe()
         Child/Nested Routes
            -> const myRoutes: Routes = [
            { path: "", component: HomeComponent },
            { path: "users", component: MySampleComponent, children: [
               {
                  path: ":id/:name", component: MySampleChildComponent
               }]
            }]
            -> In this case, the MySampleComponent should have a sperate <router-outlet>

         Redirecting routes:
            -> When specifying the path we can use the redirectTo to direct to an exising path
               e.g 
               { path: "servers", component: ServerComponent },
               { path: "users", redirectTo: "/servers" }
         Default route:
            ->  We can also use ** to configure the default path.
               e.g 
               { path: "**", component: ServerComponent }
            -> Routes are not selected based on generality, but it is based on the order we enter them. 
               Therefore very general routes should be only written in the end. 
         Notes:
            -> The path in routes should NOT begin with a /
            -> The behaviour of path to routerLink,
                  /server - appends to root path
                  server or ./server - appends to the currently loaded path
                  ../server - goes ONE level up from the currently loaded path. (This may not necessarily remove only /server. It may also remove /server/something to go one level up) 
            -> The router-outlet simply the marks the place in the DOM where we want the angular to load 
            -> Angular DOES NOT re-instantiate the Component when the route changes if it is already in that component. 
               e.g moving from /user/1 TO /user/2
               this.activatedRoute.params.subscribe((newParams: Params) => {});
               Also, when the component is destroyed, Angular automatically unsbscribes the subscription in this case(Not all cases).
            -> We can preserve the current query params by using queryparamsHandling to preserve in 
               this.router.navigate(["/servers"], { queryparamsHandling: "preserve" });

Observeables:
   -> An Observable is an easy way to subscribe to an even whcih might happen in the future. When it does happen
      we can execute some piece of code.


Modules:
    -> The modules are used to bundle different pieces(e.g Components) into packages.
     
    -> We need to use the decorator @NgModule to specify that the class is a module(just like component).

    -> sample module
        @NgModule({
          declarations: [
            AppComponent
          ],
          imports: [
            BrowserModule, FormsModule
          ],
          providers: [],
          bootstrap: [AppComponent]
        })
        export class AppModule { }

      declarations - is the list of all the Components available, 
      bootstrap    - has the list of components that angular need to know on starting server
      import       - used to import other modules


Building Angular App:
  -> Decide the Components e.g Main, Header, Footer etc..
  -> Decide the data model, so that data exchange between components is very clear.

Angular Packages:
	-> @angular/core
  -> @angular/router

Dummy notes:
1 ->	add the FormsModule  to the imports[]  array in your app.module.ts
      import { FormsModule } from '@angular/forms'; 

2 -> Updating the CLI
		 npm uninstall -g angular-cli @angular/cli 
		 npm cache clean 
		 npm install -g @angular/cli