1 -> Angular uses Typescript

2 -> Typescript is a super set of vannila JS.(i.e offers more features than vanilla JS like Classes, Interfaces and Strong typing)
		 This does not run in the browser. So, it is complied to JS in the end. This is handled by Angular CLI

3 -> We can add our own styles(Global Styles) inside of the angular.json file in styles node. 
		 If seperate module, start the path from node_modules 

4 -> index.html is the HTML file served by the server. It includes html from all the components

5 -> 

6 -> Whenever the ng serve, rebuilds the project, it will create JS bundles and automatically add the right imports in the index.html file
	 	 So the script we write in main.ts is the first things that get executed. 
		 This bootstraps/starts our angular application by passing the App module(/app/app.module.ts).
		 The app.module.ts has a bootstrap array, which lists all the components which should be known to angular
		 at the point of time it analyzes our index.html(i.e starting our server)(i.e all Components we used in index.html should
       included in the bootstrap array)

7 -> Angular uses Components to build web pages and uses modules to bundle different pieces(e.g Components)
     into packages.

8 -> We can create local reference(marker) on an element by using #someName within that element

9 -> We can use ng-template(inbuilt component/directive) to mark places in the DOM.

10 -> We can use Augury chrome extension to debug Angular apps. We can have a look at the state of the Application/Component etc..
      In the browser we can look into the src folder to find our exact source code.

11 -> Local reference are use to get access to an element in the template. They can be placed on any HTML element,
      with syntax #referenceName. This will have reference to the whole HTML element. We can use it anywhere in our template,
      but not in our typescript code(i.e need to pass in as a parameter inside of the template itself to access in TS).
      The Local reference can also be accessed using @ViewChild('localreferenceName', {static: true}) myPropertyName. Here myPropertyName has an instance of
      ElementRef (Angular obj)
      We can also get the Content of the local reference using @Content('localreferenceName', {static: true}) myPropertyName.
      We can also set localreference to some value(instead of the element itself). e.g #myRef="ngForm" 
      The @ViewChild and @Content can be used not just for local reference but also for other cases.

12 -> We can see localreference and also directives and some cases of property bindings are used with the [] in the HTML template.

12 -> Document manipulation i.e changing the element directly is highly NOT Recommended, since angular has better ways of doing it.
      i.e String Intrerpolation etc. e.g Chaging element that we have accessed through Local reference or any other means is not recommended.

13 -> Everything placed between the opening and the closing tag of our own component is lost(only takes the template within the component).
      We can change this using the Directive <ng-content>. This will serve as a hook that gets replaced by the elements
      we placed between the opening and closing tags.

14 -> It is not a good practice to directly modify elements in the Component Business logic. We can use the renderer object.
      this.rendere.setStyle(this.elementRef.nativeElement, "css-property", "value");
      Because, angular is not limited to running in the browser. This can be run in service workers, where we might not have access to the DOM.

15 -> It is better to most initializations inside of the ngOnInit func, instead of the constructor.

16 -> A component is typically destroyed when its selecector is remove from the DOM either by 
         - using the router and navigating around your app
         - when using *ngIf
         - when using *ngFor (one or more increased or decreased component).

17 -> Always don't forget. when using property binding the value inside of the "" MUST BE A TS expression.
      either the variable name or some other expression.

18 -> The localreference and the Directive, they both deal with the element they are put into.

19 -> It is always recommended to do all the heavy lifting in the services and keep the component light.
      i.e Component only has template related logic. 

20 -> entryComponents is an array of Component Types. But only of those Components which will not be 
      created either through add its selector to template or in the route config(i.e Templates added manually through code).


Components:
	1 -> There is a root component(App component) which will tie together our whole application.
	 	 We add other components to it

	2 -> Each component has its own template(HTML), styling and script

	3 -> It allows our complex application into small reusable parts

	4 -> A Component is just a TS class, so that angular is able to instantiate it. Whatever args we expect 
       in the constructor(obviously valid ones like services) is also provided by Angular while instantiating.

	5 -> We add to add Decorators(Typescript feature to enhance classes and other elements) so that angular understands its not a normal class, rather a component.
		 Need to use @sign in the front (e.g @Component)

	6 -> We need to pass some metadata to the Decorator like selectors

	7 ->  sample component
		      @Component({
            selector: 'app-server',
            templateUrl: './app.component.html',
            styleUrls: ['./app.component.css']
          })
		      export class ServerComponent {
    		  }

          selector: The tag to be used to use this template. It works just like CSS selectors
                    (i.e selecting by element tag itself, class, attributes). Also, selecting by Id/pseudo selectors are not supported by angular. 
          templateUrl: refer to an external template
          template: Actual Html template(used if very less html code)
          styleUrls: array referring to external styles
          styles: array of CSS styling string


  8 -> We need to register the component in the app.module declarations field
       because Angular will not scan our project for all components.

  9 -> We can then use our component using the selector tag in some other main component(html file).

  9 -> We need to add the Main AppComponent in bootstrap array of app.module.
  		 This bootstrap array, lists all the components which should be known to angular
		   at the point of time it analyzes our index.html(i.e starting our server)

  11 -> Everytime we use the component selector in any template, a new component object is created.

  12 -> All properties of a component are only accessible inside of that component.
        If we want to allow parent component to be able to bind to a property, then we have to
        add a decorator to that element property. @Input('alias')

  IMPORTANT - Custom property binding
  13 -> If we need to access an object inside of a component whose data is populated by a different component, 
        then we have to define the object first and expose it to outside world using the above @input() decorator.

  IMPORTANT - Custom event trigger
  14 -> We can create a custom events and also add event listeners to them just as we add it for other inbuilt events.
        e.g Creating event and make them accessible in parent - @Output myEventName: new EventEmitter<>() 
        trigger - myEventName.emit(SOME_DATA)

  15 -> If a style is defined in a CSS file inside of a component, then it is applied to only that component. 
        The way angular achieves this behaviour is by adding unique attributes to each component 
        and associating the styles to that attribute.
        This behaviour can be changed using the field encapsulation passed to @Component() (e.g ViewEncapsulation.None)

  16 -> Lifecycle hooks
            - ngOnChanges           - Called after a bound input property changes (@Input()). Note -> This does not gets triggered if any field in the object changes!!. because it will still refer to the same object.. 
                                      This hook also passes the data of type SimpeChanges. This has prev value and new value and other details.
            - ngOnInit              - Called once the component is initialized(after constructor)
            - ngDoCheck             - Called during every change detection run
            - ngAfterContentInit    - Called after content(ng-content) has been projected into view.
            - ngAfterContentChecked - Called every time the projected content has been checked.
            - ngAfterViewInit       - Called after the component's view (and child view's) has been initialized
            - ngAfterViewChecked    - Called every time the view (and child view's) have been checked.
            - ngOnDestroy           - Called once the component is about to be destroyed. 

Dynamic Components;
   -> Dynamic components are components which we add dynamically at runtime.
   -> We can use this for overlay/spinner.
   -> import in constructor - ComponentFactoryResolver.
   -> Creating a component instance should not be done by us, instead needs to be handled by Angular.
      componentFactoryResolver.resolveComponentFactory(ComponentType). This returns a Component Factory of the 
      passed Type(It knows how to create the Passed Component).
   -> Add an <ng-template> element in the template and add a custom PlaceHolder directive to it.
   -> Access the directive using the @ViewChild(DirectiveType) - This fetches the first instance of that type in the template.
   -> The PlaceHolder Directive exposes the ViewConatainerRef as a public property.
   -> Use the ViewConatainerRef object to first clear and then create the template using 
      vcRef.createComponent(ComponentFactory)
   -> Need to add it to entryComponents array in app.module.
   -> We can access the core Component instance by doing vcRef.createComponent(ComponentFactory).instance.
   -> We can use that core component instance to access properties and change its values.
   -> Important to note here is that the Data binding, @Input and @Output will all not work here.
      We have to manually do data manipulation using the above core component instance and also listen to events
      by manually subscribing to those events. 
   -> When we move away from the dynamic component we have to do vcRef.clear() and also clear the 
      above event subscription.

Databinding:
    -> Communication between TS code and the HTML template
    -> Outpu data (from TS to HTML)
        -> Types:
          -> String Interpolation {{data}}
          -> Property Binding [property]="data"
    -> React to user events (HTML to TS)
          -> (event)="expression"
    -> Two way data binding  (HTML to TS and vice versa)
          -> [(ngModel)] = 'data'

      -> String Interpolation:
            -> Within the {{ }}, we can write any Typescript expression(single line) which can resolve to a string.
               e.g referring a property, calling a function which returns a string

      -> Property Binding:
            -> Square brackets indicate to angular that we are using property binding
               e.g [disabled]="propertyName"
            -> Inside of the double quotes, we can write any TS expression same as in string interpolation
            -> we can not only bind to HTML elements but also to directives and to our own components.
            -> We can do custom property binding using the @Input('alias') fieldName. and then using ['alias'] in the outerParent Component
            -> If we pass down a string like [property]='"myString"', then we can omit both the [] of property and also the "" in the value.
               But, we have to make sure that it does not conflict with the default element property.
            -> If after the value is set, the user changes the value. This does not update the property of the component. 
               This is only possible through two way binding.
            -> Property binding is NOT Possible with a directive per say.(except for custom property binding using @Input)
      -> Event Binding:
            -> On any HTMl element, we use do (event)="TS expression". The event can all the events supported for that element.
            -> Inside of the quotation marks, $event will be the date that was emitted with the event.
               Typecasting may be needed to use the data values(HTMLInputElement)

      -> Two way data binding:
            -> With this we combine property and event binding. The syntax is also combined.
            -> e.g [(ngModel)]="TS Variable", this will trigger in the input event and update the value of the variable in our component automatically.
               Also, It will update the input value if we chnage the value of variable somewhere else.


Directives:
    -> They are instructions in the DOM. (e.g Components are directives with a template 
       i.e they tell angular to use the template based on the selector)

    -> We usually add directives with an (attribute) selector, but the selector of the directive can also be like 
       the selector of a Component(i.e Element selecector). 

    -> example *ngIf
          -> The * is needed is needed because ngIf is a "structural directive" because, it changes the structure of the DOM.
             i.e it either adds the element or doesn't add it(i.e Element is not hidden)
          -> The value assigned should be any expression which returns true or false. 
          -> We can also else in ngIf using markers like *ngIf="someValuse; else myMarker"

    -> ngStyle
        -> This is an "attribute directive". They don't add or remove elements rather only change the element they were placed on
        -> e.g [ngStyle]="". The square brackets here is not the directive name. The square brackets indicate 
           that we want to bind some property on this directive and the property name is also ngStyle.
        -> This expects a JS object with style name and value. The value can also be returned from a function.
        -> It allows us to dynamically update the styles.
        **** IMPORTANT ****
        -> If a variable value is changed, event if it is not directly accessed(e.g calling a function that returns that value),
           the changes will still be reflected in the DOM.
    -> ngClass
        -> This is also an "attributive directive".
        -> [ngClass]=""
        -> This expects a JS object with class name and value. The value can also be returned from a function.
        -> It allows us to dynamically update the CSS class.
    -> ngFor
        -> This is a structural directive. This is used for looping over the element
        -> *ngFor="let server of myArrayName"
        -> The let variable can be accessed directly in any TS expression, 
           but in the HTML space we have to use string interpolation to access it.
        -> let i = index, can be used to access the index of the current iteration.
        -> We cannot have more than 1 structural directive on a single element.
    -> ngSwitch
        -> Sample 
            [ngSwitch]="value"
                *ngSwitchCase="10"
                *ngSwitchDefault

            Note:
              -> No * for the initial ngSwitch

    Custom Attribute Directives:
        -> We can have our own business logic inside of a Directive and put it into any HTML element.
        -> We can inject the element the direcrtive sits on into this directive.(Angular does this).
        -> We can use @HostListener('event') funcName () {}, to listen to events automatically and also react to them(logic inside of func).
        -> We can use `@HostBinding(style.backgroundColor) myField: string` to bind a property to a TS property
           and change it in our code as a reaction to something.
        -> Sample directive:
            @Directive({
              selector: "[appHighlight]"
            })
          Note:
            -> selector is written as camelCase
            -> Need to mention the Directive in App.Module file
            -> while using the directive, we have to use it just the directive name(i.e without the [])
        -> We can bind to properties of our own directive, by simply placing them on the same element enclosed in squarebrackets.
        -> We can also have any one Main property the same name as our directive. In this case, 
            we should not mention the Directive(without square brackets), rather the property binding of the property mentioned above.

    Custom Structural directives:
        -> <*ngIf> is same as -> <ng-template [ngIf]="sampleField"> </ng-template>
        -> Sample
            @Input() set myDirName (cond: boolean) {     // This is still a property, but this gets executed when the value passed to it(input params) changes
              if (!cond) {
                this.vcRef.createEmbeddedView (this.templateRef);
              } else {
                this.vcRef.clear();
              }
            }

            constructor(private templateRef: TemplateRef, private vcRef: ViewConatainerRef) {}

            Note: 
              -> templateRef gives access to the template(ng-template - see point 1) and vcRef gives access to the view conatiner(This marks
                 the place where we place the directive in the document)
              -> Property name should be same as Directrive name. 

      Notes:
         -> A directive if placed on an element, is just a new instance of a class(The Corresponding Directive class)
            which has more details about that element and it can control that element.

Services:
    -> Service is just another class, which acts a central business unit
    -> Duplication of code, data storage, providing data are typical use case of a Service
       e.g Logging service, User service(storing user data)
    -> A service can be created by just creating a class.(No decorators needed, no need to add to app.module)
    -> A service can be used in a component by adding them in the providers field in the @Component decorator and 
       using the service in the constructor.
    -> Always try to call the service functions and data from the Component TS file, rather than
       the component template itself(i.e don't attach event listeners to them directly)

Injection:
    -> Easy way to get access to some other classes, without having to instantiate them.
    -> The Angular dependency injector is actually a hierarcial injector. i.e if we provide a service for one component,
       then angular knows how to create an instance of a service to that component and also all its child component.
       i.e The Component and all its child components will receive the same instance of the Service
       i.e The Instances don't propogate Up. They only go down
    -> We can provide services at the 
          -> AppModule(whole app gets the same service instance including components and services)
          -> AppComponent - All components gets the same service instance but not the not services
          -> AnyOther Component - Same instance of the service is availabe for the Component and its child Component.

          Note:
            -> If we provide a Service instance to a child Component. It will override if we were to provide the same
               service at a higher level.
            -> To use the same service in the child component, don't add it to the providers field. 
               But have to add it to the constructor.
    -> We can inject one service into another service. For that we have to use the @Injectible decorator. 
       By this we are telling that this service can be injected. This has to be added at the receiving service.
    -> We can also make cross component communication by emitting event from the service(in one component) and
       subscribing to it in another component.
    -> In Angular6+, instead of adding a service class to the providers[]  array in AppModule. We can do
        @Injectable({providedIn: 'root'})
        export class MyService { ... }
        By this, Services can be loaded lazily by Angular (behind the scenes). 
        This can lead to a better performance and loading speed.

Router:
   -> Sample
          1. 
          Inside of app.module
          const myRoutes: Routes = [
            { path: "", component: HomeComponent },
            { path: "users", component: MySampleComponent }
          ]
          2. 
          add the RouterModule to imports in app.module
          actually, RouterModule.forRoot(myRoutes)
          3. 
          Add special directive(yes directive with element selector(usaully directives are property selectors))
          <router-outlet></router-outlet>

          Navigating Links;
            -> We have to use a special directive called routerLink=""
            -> The routerLink also supports array value - ["/users", "sample"]. Note, only first index needs to have / 
          Styling Active Router links:
            -> routerLinkActive Directive can be used to add class for an active tab.
            -> We can add it to the wrapping element or the link itself
            -> routerLinkActive="myClass".
            -> It analyzes our currently loaded path and checks which link leads to a route which uses this path.
               It then marks the element as active if it CONTAINS the path.
            -> Above creates problem for the ROOT path since all routes contain the root path. In this case we have to add
               [routerLinkActiveOptions]="{ exact: true }"
         Navigating Progmatically:
            -> We can do it using the Router from @angular/router
            -> this.router.navigate(["/servers"]);    Note, only first index needs to have /
            -> This always apppends to the root path. If relative path is needed we have to configure it as
               Add the ActivatedRoute Interface and then this.router.navigate(["/servers"], { relativeTo: this.route }); route refers to ActivatedRoute.
         Adding Dynaimc paths:
            -> While defining route. we can do "users/:myName"
            -> Inside of the loaded component, we can access the dynamic param by importing the ActivatedRoute.
               this.actRoute.snapshot.params.myName
         Passing Query Params:
            -> [queryParams]="{myKey: 'myValue'}". This is another bindable property of the routerLinkDirective
            -> Progmatically - this.router.navigate(["/servers"], { queryParams: {} });
            -> Can be accessed by this.actRoute.snapshot.queryParams and also can be subscribed for changes using
               this.actRoute.queryParams.subscribe()
         Passing Fragments(#):
            -> fragment="someValue". This is another bindable property of the routerLinkDirective
            -> Progmatically - this.router.navigate(["/servers"], { fragment: "myFragment" });
            -> Can be accessed by this.actRoute.snapshot.fragment and also can be subscribed for changes using
               this.actRoute.fragment.subscribe()
         Child/Nested Routes
            -> const myRoutes: Routes = [
            { path: "", component: HomeComponent },
            { path: "users", component: MySampleComponent, children: [
               {
                  path: ":id/:name", component: MySampleChildComponent
               }]
            }]
            -> In this case, the MySampleComponent should have a sperate <router-outlet>

         Redirecting routes:
            -> When specifying the path we can use the redirectTo to direct to an exising path
            -> We cannot redirect from an empty path ""(root path), because all paths contains/begins with an empty path
               This can be fixed with pathMatch : 'full'.
               e.g 
               { path: "servers", component: ServerComponent },
               { path: "users", redirectTo: "/servers" }
         Default route:
            ->  We can also use ** to configure the default path.
               e.g 
               { path: "**", component: ServerComponent }
             
         Route Guards:
            -> Functionality, logic which is to be executed once the route is loaded or once we want to leave a route
            -> With this we can provide security to the routes.
            -> Create a service which implements CanActivate
            -> Need to implement the interface function canActivate(ActivatedRouterSnapshot, RouterStateSnapshot) 
            -> Go to the place where we define the routes(paths, children etc..) and add a new field canActivate: [AuthGuard]
               This applies the auth-guard to all child routes too.
            -> We can only activate guard for child routes by adding the canActivateChild: [AuthGuard]. In this case we need to implement
               a new Interface CanActivateChild which asks us to implement a canActivateChild method which does the actual authtication.
            -> From CanActivate, we can return a urlTree to navigate user to a differnt route. this.router.createURLTree(["/auth"]).
            -> Controlling Navigation(CanDeactivate Guard):
               -> Conventient method of keeping the user from accediently navigating away from a page.
               -> Create a service which implements CanActivate
               -> Go to the place where we define the routes(paths, children etc..) and add a new field canDeactivate: [CanDeactivateGuard]
               -> The logic may have to reside in the current Component since it may some useful data
                  like whethere should we ask the user in the first place(i.e no changes made) 
                  But the CanDeactivateGuard needs to be a service. So, we need to connect a Component to a service.
                  i.e We will call canDeactivate() from the service to the component. In order to make sure that the component
                  always has the canDeactivate method we make the Component to implement an Interface(newly created just for this purpose) which has that method.
                  Note: the canDeactivate method receives the current Component(All the extra interface type is just a safety thing)
         Passing static data:
            -> The data property(while defining routes), allows us to pass on static data specific to that route to the Component 
            -> we can access that using this.activatedRoute.snapshot.data
            -> We may have to subscribe to it so that we listen for changes for data.
         Resolver Guard:
            -> This is also a service whcich allows us to run some code before a route is rendered.
            -> This will NOT decide/block whether this route should be rendered or not. 
            -> The alternative is to render the page instantly and then do this in ngOnInit(i.e with a spinner)
            -> A new service class implementing Resolve Interface which forces to implement the function resolve.
            -> The place where we define route, need to add resolve: { myAnyProperty: MyResolver }
            -> we can access that using this.activatedRoute.snapshot.data
            -> We may have to subscribe to it so that we listen for changes for data. 
         Location stratergies:
            -> We need to pass in the configuration in RouterModule.forRoot(myRoutes, {useHash: true}).
            -> This informs our web server to only care about the part before the #(i.e only local:4200). 
               Rest will be parsed by angular.
            -> This is done to give angular full control of the routing to the angular(Specific handling in case of Route not found etc..)

         Notes:
            -> The path in routes should NOT begin with a /
            -> The behaviour of path to routerLink,
                  /server - appends to root path
                  server or ./server - appends to the currently loaded path
                  ../server - goes ONE level up from the currently loaded path. (This may not necessarily remove only /server. It may also remove /server/something to go one level up) 
            -> The router-outlet simply the marks the place in the DOM where we want the angular to load 
            -> Angular DOES NOT re-instantiate the Component when the route changes if it is already in the same component.
               e.g moving from /user/1 TO /user/2
               this.activatedRoute.params.subscribe((newParams: Params) => {});
               Also, when the component is destroyed, Angular automatically unsbscribes the subscription in this case(Not all cases).
            -> We can preserve the current query params by using queryparamsHandling to preserve in 
               this.router.navigate(["/servers"], { queryparamsHandling: "preserve" });
            -> The routes are usually added as a seperate module. e.g app-routes.module.ts
               So need to add the @NgModule decorator.
            -> If the routers are moved to a seperate module, then we need to export(field: exports) the RouterModule from (@angular/router)
            -> Only the component is not rendered if already existing, but the route will be called(with all its guards and other things)
               each time we move to the same/different route.
            -> Routes are not selected based on generality, but it is based on the order we enter them. 
               Therefore very general routes should be only written in the end.
               Also, dynamic routes should go after specific named routes. Because angular cannot differentiate 
               between /:id and /new (new will be considered as a dynamci value).
            -> RouterModule.forRoot(myRoutes) can be used only once in the application. In all other feature modules, 
               we have to use forChild()
            -> We can also create a shared module which groups all the shared Components, Directives etc..
            -> We can only declare Components, Directives, Pipes only once in our application. But, we can import a Module multiple times.
            -> We can also use core module to export all the services into one module to make app.module a bit clear.
               This is only needed if we are going to use the providers array in app.module(i.e Not needed if we used @Injectable({providedIn: "root"}))

Observeables:
   -> An Observable is an easy way to subscribe to an even whcih might happen in the future. When it does happen
      we can execute some piece of code.
   -> It can be thought of as a data source. In angular it is just an object we import from a third party package(RxJS).
   -> It is implemented as an obervable pattern. We have an Observable and an observer.
   -> In between this, there is a stream/teamline. We can have multiple events emitted the observable during that time(e.g chnage in data).
   -> Observer with the data received can Handle Data, Handle error or Handle Completion.
      Some Observable may not have data completion(e.g observable hooked to a button)

      Creating Observeables
         -> We can import the interval function from rxJS. This inturn returns an observable
            interval(1000).subscribe((count) => { console.log(1) })
         -> It is extremely important that we manually destroy/unsubscribe an observable after we are done/move away from the associated component.
            Observables provided by angular like params observable are automatically destroyed by angular itself when we move away from the component.
         -> Sample custom observable from sratch

            Observable.create((observer) => {}).        
               // Observable imported from rxJS and the arrow function is called whenever the Observable get a new observer.
               setTimeout(() => {
                  observer.next("someData");
               }, 1000);
            })
            observer can be called with next(), error(new Error("my error")), complete() for corresponding cases.

      Operators;
         -> The data points first reach the operator, then the observer(Sits between the Observable emitted event and the subscriber handling method).
         -> We can use them by calling the pipe method. This does not change the data we receiev from the subscribe callback, 
            unless we subscribe to the observable after applying the operations(i.e after calling the pipe method).
            Also, the pipe method takes an unlimited number of operators which are executed one after the other.
         -> We can use the tap Operator which does not modify the data, but lets us to do something with the data(e.g console.log).
            Different types of Operators
               take        - Says we only want n values from the Observable and after that we should automatically unsubscribe.
               exhaustMap  - It waits for the first Observable to complete and returns a new Observable from within.

      Subject:
        -> Subject is a special kind of Observable. It is also something we can subscribe to, but is active, 
           because we can actively call next on it from the outside.
           We can call next() and other Observable related methods on it. But the difference is, we call then anywhere
           we want(outside of the Observer like above), if we have access to the Subject instance.
        -> We should use Subject instead of EventEmitters and Observables, as they are bit more effecient behind the scenes.
        -> We should also destroy them when we no longer need them(just like Observers).
            Creating Subject:
              mySubject = new Subject<boolean>()        // The return value is specified as boolean.
      
            Notes:
              -> Observable.create(() => {}) is similar to new Subject<>().
              -> Subject should only be used to communicate across Components and not withhin the same Component(i.e like using in case of @Output).
      BehaviourSubject:
         -> This is same as the Subject, but with the difference that it gives immediate access to the previously emitted data,
            even if the one acessing haven't subscribed when the value was emitted.
      
      Notes:
        -> Whenever an observable throws an error. It dies and stops further occurences.
           Also, an error does not trigger the observer.complete method. 
        -> The subscribe method has a second arguement(function), which we can use for error handling. 
           Also, third argument can be used to react to observer completion

Modules:
   -> The modules are used to bundle different pieces(e.g Components, Services, Pipes, Directives) into packages.
   -> We need to use the decorator @NgModule to specify that the class is a module(just like component).
   -> Every module works on its own in Angular(i.e They don't communicate with each other)
      i.e We can use a Component declared in a module inside of other components besides it(declared within the same )
      But, we cannot use them in a Component of a different module.
      With the exception of services, which are available application wide.
   -> When we import another module, we import everything that module exports.


   Notes:
      -> Splitting the app into feature modules is the prerequisite to performance improvements.
      -> We can add CommonModule to access ngIf and ngFor. In app module it is available through BrowserModule.
         But since BrowserModule does many things in app start up we have to include it only once.

    -> sample module
        @NgModule({
          declarations: [
              AppComponent
          ],
          imports: [
              BrowserModule, FormsModule
          ],
          providers: [],
          exports: [],
          bootstrap: [AppComponent]
        })
        export class AppModule { }

        declarations - is the list of all the Components available, 
        bootstrap    - has the list of components that angular need to know on starting server
        import       - used to import other modules
        exports      - this simpley tells angular, if the current module is to be imported
                       in any other module, what should be accessible to the other module 

   Lazy Loading;
      -> 

      -> Pre Loading:
            -> While register routes, router.forRoot(myRoutes, { preloadingStratergies: PreLoadAllModules })

   Notes:
      -> Adding a service to an eagerly loaded module has the exact same effect as adding it to the providers of app.module or 
         providedIn: "root". But if added to a laxy loaded module, then it is only available to that module alone and it gets its own instance.
         If we provide in both eagerly loaded and lazy loaded, the service will be available application wide but the lazy loaded
         module will have a seperate instance.
         So, loading services into Eagerly loaded modules should be avoided as this is very unexpected.

Forms:
    -> Angular gives us a javascript object representation of the form and also some validations.
    -> In angular, a form is just a Grpup of controls(we can define each control). This is held by the FormGroup(which is wrapped by ngForm in case of template driven approach )
    -> Approaches supported by angular.
          -> Template Driven
          -> Reactive approach. Manually setup the structure of the form, then template, then manually connect it to the structure.
    -> Steps - Template Driven:
          -> Import the FormsModule in app.module.
          -> Need to inform angular which form elements need to be controlled. Can be achieved by adding ngModel directive(without [()] in it).
          -> Also, need to add the name attribute.(field name in JS Object representation).
          -> When we click on a button inside of a Form(with type="submit" or only one button in a form), its default behaviour is to trigger a submit event. 
             Angular uses this event using the directive ngSubmit, placed in the form element itself. 
          -> A localreference set to "ngForm"(#f="ngForm") and passing the localreference as part of the handler for the submit event above.
             We can also access the form data(JS object) created by angular on an individual Element by doing #fE="ngModel"
        Notes:
          -> The form element is kind of like a selector for a directive built into angular, which creates the JS object of the form automatically.
          -> The required(Html attribute) is also an Angular Directive
          -> email is also a Html directive. We can access the list of dieectives from - https://angular.io/api/forms/Validators
          -> Angular adds its own CSS classes(e.g ng-dity, ng-valid etc), giving us information about the state of the individual control.
             We can use this classes to make our own styling.
          -> We can also use [ngModel]="myField" to show default values.  
          -> We can use ngModel as just like that(to mark it as form control) or one way binding(default value) or also as two way binding
          -> We can use the ngForm instance(accessed through local variable) to also set the values of the WHOLE form.. e.g this.localRef.setValue({}).
             The data passed should be of the same structure as defined in the form.
             We can override only specific values using  this.localRef.form.patchValue({})
          -> We can also reset the form using this.localRef.reset(). This will make the form as just loaded.(i.e untouched etc. will be true). 
             We can also passs in the object just like in setValue to reset to a specific values.
         -> There is validator named pattern, which allows us to do regular expression validation on the form control.
      -> We can also group data by using ngModelGroup="groupName". We can now also do validations based on this group(just like individual FormControl)
         Can be assessed using local reference, #localref="ngModelGroup"

    -> Steps - Reactive Approach
        -> The form needs to be created programatically(in TS code). 
        -> myForm: FormGroup     (as discussed earlier, form is just a group of control).
        -> Import the ReactiveFormsModule.
        -> Initialize the form(myForm), before rendering the template.
        -> this.myField = new FormGroup({
              username: new FormControl("initial value")        // initial value, single/array of validators, asynchronous validators.
           })
        -> In the template, add the [formGroup]="myForm" directive to the Form element. This tells angular our own form group created earlier.
        -> For each individual form control element, we should add the directrive formControlName="propertyName as just string" directive.
        -> For accessing the form on submit(or any other time), we don't have to go through the localref way as done previously for Template form.
           We can just access the same formGroup instance we created in the above steps. This will have all the details just like ngForm. 
        -> The validation can be selected from the Validation classs. e.g [Validation.required, Validation.email] 
        -> We van get access to our controls, using the myForm.get('controlName')     // controlName(no nested) or path to control
        -> We can group controls by using the FormGroup class again.
           this.myField = new FormGroup({
              userData: new FormGroup({
                username: new FormControl("initial value") 
              })
           })
           Then in the tempate, we need to use formGroupName="formGroupNameAsString". But formControlName still remains the same(No need to define the path)
        -> FormArray is an array of form controls/FormGroup. We can add formcontrol/formGroup dynamically.
           Inside of the template, we can sepecify FormArray using formArrayName="stringFormArrayField"
           We can iterate using *ngFor=let myVar of myDummyFunc()       // myDummyFunc returns all the formcontrols which we can iterate.
           The name of the FormControl will just be the array index itself. 
           We can push new Controls using (<FormArray>this.myForm.get("stringFormArrayField")).push(new FormControl())
           We can also remove FormGroup or FormControl elements in a FormArray at a certain index. (<FormArray>this.myForm.get("stringFormArrayField")).removeAt(1)
           or all items at once using (<FormArray>this.recipeForm.get('ingredients')).clear();
      -> Adding own  validators
          -> It is just a function, which receives a formcontrol instance.
              myValidator (formControl) { [s: string]: boolean }
          -> we can pass a reference to the above function in place where we pass in built-in validators.
              Note:
                -> If validation is successful, we have to pass nothing  or null. else we can 
                   return an object with some error code as fieldName and value as true. 
                -> Angular adds the error we pass to the error field of the formControl. We can access that error and
                   show appropriate error message. This is true for inbuilt validators too.(But need to check the error name incase of built in validators)
      -> Add Syns validators:
          -> It is a function, which receives a formcontrol instance and returns a Promise or Observable.
              myValidator (formControl) Promise<any> | Observable<any>
          -> The above also resolves to an obect like we retuned previously for non-async function for validation failed.
          -> This needs to be passed in as the third param while definining FormControl
      -> Reacting to changes:
          -> We can subscribe to value changes and status changes(e.g pending in case of async validators)
             on the formObject or the individual formControl Object.
            e.g this.myForm.statusChanges.subscribe()
                this.myForm.valueChanges.subscribe()
      -> Setting/Pathc/Reset Values:
          -> on the formObject we can call setValue({ })    // set whole form
          -> on the formObject we can call patchValue({ })    // set some fields
          -> on the formObject we can call reset({ })    // reset form values

Pipes:
   -> Pipes allow us to transform output in our template.
   -> e.g
         {{ name | uppercase }} OR {{ myDate | date }}
   -> We can pass parameters using the : after the pipe .eg date:"param1":"param2":"param3"
   -> We can chain pipes by adding | after a pipe(order is important)

      Creating Custom Pipes:
         -> Create a file like shorten.pipe.ts
         -> implement PipeTransform and implement the transform method
         -> Add the @pipe({ name: "shorten" }) decorator
         -> transform(value) {
               return "newValue"
            }
         -> Add the pipe class to app.module declaratons array.
         -> By default, angular does not re-run our data on our pipe whenever there is a data change(change in array or object), 
            we can change this behaviour by adding `pure: false`. But, this might cause performance issues.
            Also, when the data is run by two or more pipes, all pipes need to have this done so that it is re-run for all pipes when data changes
            Otherwise only those which had it done will be run through our data when it changes.

      async pipes:
         -> This pipe can be used to display data which initially will resolve to a Promise or an Observable.
            This will automatically update the value with data resolved by Promise or data received by Observable.
            {{ appStatus | async }}

HTTP requests:
   -> Creating HTTP requests:
         -> Import the HTTPClient Module
         -> Add/Inject it to the constructor of the component.
         -> Use the above instance to make HTTP requests.
         -> We can handle errors by using the second parameter of the subscribe method or using the Subject to emit error data.   
         -> We can use catchError Operator to do some hadling in case of Error occuring. Also, in this case we could 
            return a new Observable called throwError which wraps the actual error(This Observable does nothing but emits an error with the data supplied).
         -> We can pass headers as part of the options in the secnd param of the HTTP method functions.
            e.g header: new HttpHeaders({

            })
         -> We can pass params as part of the options in the secnd param of the HTTP method functions.
            e.g header: new HttpParams().set("field", "value")
         -> We can tell what we want as a result from a HTTP request. By default it is the parsed response body.
            But, we can also tell angular to give the entire response (including headers, statuscode etc).
            This can be achieved by setting "observe": "response"(options parsm of HTTP method).
            Possible values: body(default), response, event
         -> Using the above, we can listen to the HTTP events to track the state of the request.
            i.e is the request sent to server, is the response received etc..
            We can differentiate between the states using the type key(has value of 0, 1, 2, 3 etc..)
         -> We can also set the responseType using the options object.

      Interceptor;
         -> We need to create a Service class(e.g AuthInterceptorService) which implements HttpInterceptor
            which forces to add the intercept method(request: HttpRequest<any>, next HttpHandler).
            This will run before the request leaves our application. We need to return next.handle(request).
         -> In app.module file in the providers field add 
            {
               provide: HTTP_INTERCEPTORS,
               useClass: AuthInterceptorService,
               multi: true                         // No not override the existing interceptors and have multiple interceptors
            }
         -> Inside the interceptor, we can modify the request by cloning the actual request(since the actual request cannot be modified),
            e.g let modifiedReq = req.clone({url: "xyz", headers: request.headers.append("abc", "xyz")});
         -> The Order in which we provide the Interceptors matter, since that is the order it will get executed.

         Response Interceptors:
            -> The next.handle() returns an Observable. We can use pipe to manipulate the response.

            Note:
               -> The tap Operator always gets an event in this case(inside of an Interceptor), irrespective what we chose to Observe.

         Notes:
            -> Requests are only sent to the server when we subscribe to the Observable returned by .post/.get method.
            -> All methods are generic, we can use them to define the response schema. e.g .get<{ name: string }>() 
            -> The error received is of type HttpErrorResponse

Building Angular App:
   -> Decide the Components e.g Main, Header, Footer etc..
   -> Decide the data model, so that data exchange between components is very clear.

Starting Angular Project from scratch;
   -> create a new folder src
   -> create a new folder src->app

Deploying Angular Apps:
   -> Deploy to a static host. Static host is a web server that is capable of serving HTML, JS, CSS
      but not capable of running any server side language.
   -> src -> environment. It has a const and we can add key value pair to that constants. e.g ApiKey
      We can require the environment file and use the constants.
   Building Angular Apps:
      -> The ng build 
            - compiles TS code to JS
            - compiles all templates to JS Instructions (i.e in the end only JS code is generated)
              JS code conatins all the logic for updating the DOM.
            - Translated to Angular language(so that Angular renderer can work with it in the browser) 
   Routing after deployment:
      -> Angular stores and manages your routes, not the server thats hosting your Angular app!
      -> The server only serves the index.html file - thats about its only job!
      -> Therefore, our server cant do anything with an incoming request pointing at a /products route.
         its totally unknown to it!. Due to the way the web works, requests reach the server though
         and your client (i.e. the Angular app) DOESN'T EVEN GET LOADED as the server throws a 404 error.
         i.e The very first request from the client to our app.
      -> Thus, our server should always serve the index.html file, especially in 404 error cases!

Angular Universal:
   -> It allows us to pre-render our angular app on the server(pre-rendered HTML pages to the user).
   -> Improves web crawler score
   -> ng add @nguniversal/express-engine --clientProject ng-my-project(project name as in angular.json)
   -> npm install --save nguniversal/module-map-ngfactory-loader. This is done to enable lazy loading.
   -> Inject using @Inject(PLATFORM_ID) to identify which platform our app is running. 
      This tells angular to look for a globally provided value with this identifier(PLATFORM_ID)
   -> Import the method isPlatformBrowser from @angular/common. This is done to not execute browser specific code
      on the server(like fetching from localstorage)
   -> The page will be prerendered on the server, but once it is served, it will run again on the browser.
   -> npm run buid:ssr
   -> A Node js server is needed.
   -> npm run serve:ssr

Service Workers(Offline):
   -> Google dev tools -> Application -> Service workers -> Offline
   -> JS offers us to run additional threads(Web Worker i.e Service Workers).
   -> This can be used in mobile to receive push notifications etc..
   -> It can listen to outgoing Networks request (e.g fetching the assets off that web page - 
      javascript or CSS and also data from an API.
   -> The service worker can catch these outgoing requests and do something with them(like caching). 
   -> ng add @angular/pwa
   -> To ensure new build updates the service workers, resources will contain a Hash which will be injected into the service 
      workers. Thats why build process needs to be aware that there are service workers configured.
   -> The service workers can be considered as a proxy between our angular app and our backend server.
      It catches and might still allow request to leave the app or it may block the request.
   -> manifest.json - for launcher icons(mobile apps).
   -> ngsw-config.json file - We can configure the service worker that gets generated.
   -> We need to have a web server(http-server)
   -> assetGroups for static content and dataGroups for Dynamic data.


Dummy notes:
1 ->	add the FormsModule  to the imports[]  array in your app.module.ts
      import { FormsModule } from '@angular/forms'; 

2 -> Updating the CLI
		 npm uninstall -g angular-cli @angular/cli 
		 npm cache clean 
		 npm install -g @angular/cli

