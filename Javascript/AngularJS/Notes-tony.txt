1 ->  It is based on MV* architecure.
      Model        - data or $scope
      View         - Template with a controller
      *(anything)  - Watchers and the digest cycle       // This connects the model and the view.
2 ->  We will not pollute our global name space by only adding a variable named app(ourApp).
      angular.module('myApp', []);     // array of dependencies
3 ->  All angular JS services name starts with a $ sign. (e.g $scope etc..)
4 ->  We have to use $scope.$apply(myFunction) if we are working outside of the Angular Context(e.g Async requests).
      This tells angular that after the code within it is run, Angular JS runs the digest cycle to check for any changes.
5 ->  If we split Controllers, Routes, Services and Directives into seperate JS files, then we have to include all of them in the app.js(Main JS) file.
6 ->  Good practice to add new directives in a new line of the HTML element.
7 ->  We can have some logic during app startup inside of angular.module('app').config(function($stateProvider, $urlRouterProvider) { }).
      Usually used for adding routes
8 ->  We pass data down from parent components to child components using property bindings and pass data up from child to parent using events.
9 ->  All JS expressions needs to be enclosed inside of the {{ }}, except for the directives for which we can have them inside of string itself.
      e.g ng-show="2+2" will work, but some-attr="2+2" will not work.
10 -> We have to be careful in using $scope.$apply(), since this will throw error if a $apply is already in progress(due to some other trigger).
      We can overcome this by wrapping our code inside of $timeout(function() {}, 100). This is same as setTimeout, but it runs in the angular context
      (i.e Digest cycle will know about the changes)



IMPORTANT
Naming Conventions:


Constants             - UPPER_CASE_SNAKE_CASE
Values(.values)       - PascalCase



Composed of 
  -> Modules          (Main module and features)
  -> Components       
  -> Directives       (Bind to HTML and extend behaviour)
  -> Services         (Business logic or non view related logic)
  -> Routing + Views  (Usual routes and View is considered as a template of a route)
  -> Controllers      (View related logic and model for the view)


Modules:
  ->  Create a module
      angular
        .module('app', [])      // array of dependencies if any, need to pass even if no dependencies
  ->  loading module, add ng-app="app" as an HTMl attribute. Usually put at the very top of the HTML doc(i.e inside <html> tag itself).
  ->  The dependencies can be any built-in module or our own module.
  !!!!!!!
  ->  If we inject any new module, then we can use all of its Directives and Services(dependency Injection) in our app WITHOUT US DOING ANYTHING.
      In this case, we first need to download the dependency JS file(using src="/path" OR URL).
  ->  If we call angular.module('app') (i.e without the second [] argument), then it returns the appModule anywhere inside of the code.
      
      Adding a dependency module:
        ->  Copy and paste the soure code(or can use other build tools like npm etc..)
        ->  Load the JS file in index.html after angular.js file
        ->  Add the dependency to the needed module.

      Notes:
        -> Features should more likely be a Module.
      

Components:
  ->  A component is a combination of a Controller and a Template. For anything that uses a controller and a template, we should be using a Component.
  ->  angular.module('app').component('myComponent', {
      })
      Component properties:
      bindings:                   // same as bindToController
      controller:                 // same as in Direcive
      template:                   // same as in Direcive
      transclude:                 // same as in Direcive
      require:                    // Object with namespace and the component name. e.g { parent: "^^parent" }
      
      Bindings:
        ->  For one way binding, the data is passed from the parent to the child component. The passed data is mutable, so we have to do angular.copy() inside of
            $onChanges to make a seperate copy for the child(i.e so that we don't modify parent data right away when child data gets modified)
            The child component, when needed passes the updated data through an event(function exposed by the parent component)
        < - One way data binding. data="parent.data"            // NO {{ }}
        @ - Text. One way data binding. use {{ field }}                 // It is important that we use {{ }} in this case.
        & - Function binding
      Require:
        ->  We cannot use the parent require Object before onInit life cycle.
        ->  We can just access it inside the child component using `this`.namespace
        
  ->  They always have an isolated scope(i.e Have their own scope).
  ->  The default alias for the component is $ctrl. i.e should use $ctrl inside of the template.
      Types:
        -> Stateless Component:
            ->  This only has a Controller and a template
        -> Stateful Component:
            ->  This has a Controller and a template and also a Service. (Stateful because the service data is persisited across application)
            ->  They are typically higher up in the hierarchy.
        -> Routed Component:
            ->  It is same as a Stateful Component with addition of routing.
            ->  The template here is usually treated as Views.
            ->  They also act as the rooted Component(i.e Component at the top level).
      Life Cycle Hook:
        $onInit: 
          ->  This lifecycle hook will be executed when all controllers on an element have been constructed and after their bindings are initialized.
              This hook is meant to be used for any kind of initialization work of a controller. 
          ->  this.$onInit()
        $postInit: 
          ->  This gets called when the child components are ready and have been linked.
          ->  Good place to do some DOM manipulations as all child components are loaded and safe to access.
          ->  this.$postLink()
        $onDestroy: 
          ->  This gets called when the component scope gets destroyed.
          ->  We can use this hook to release external resources, watches and event handlers.
          ->  this.$onDestroy()
        $onChanges:
          ->  This hook allows us to react to changes of one-way bindings of a component.
          ->  The first time it gets called, is on component initialisation.(i.e parent to child)
          ->  It gets called with an object that holds the changes of all one-way bindings with the currentValue and the previousValue.
          ->  One way data bindings include < and also @ expression in the bindings.

Controller:
  ->  myApp.controller('controllerName', function() { })
      Inside of our HTML template, do ng-controller="controllerName"
  -> A controller is nothing but a single function having all the logic for handling/manipulating the view.
  -> The Controller ties the data($scope) to the View template associated with the controller in HTML.
  -> All params used in the function of the controller are dependency Injection params.
  -> We should try to only have logic related to the view inside of our controller(i.e Move other business logic to Services).
  -> To solve variable name changing during minify, instead of the controllerNameFunc, we should be passing in an array, which has all the dependencies names and the controllerNameFunc as the last item in the array.
     The order of the dependencies names in the array is very important.
     OR
     controllerNameFunc.$inject = ["$scope", "$rootScope"]          // Both are same
  ->  We can also use alias for Controller inside of the template. e.g MyController as controller.
      This helps in clear confusion when we have similar field names in nested controller templates(i.e Parent, then Child etc..). Also, we can clearly access the parent field inside of the child template using the alias.
      By using this we can completely skip the $scope and just use `this` inside of the controller(This will bind the data attached to `this` to the scope of the controller).
      If we changed to this syntax, then all places where the controller is used(inside of Templates and others) needs to be accessed like an alias(using Controller As)
  ->  All fields accessibile inside of the parent component are also accessible inside of the child component. 
      If Angular did not find a particular field inside of a child component, it goes one level up and looks it up in the parent component and it goes on untill it finds the field.

View/Template:
  ->  Inside of our ng-app="myApp", we can define our view. 
  ->  It is nothing but a simple HTML template with a controller associated !!!..
  ->  A template needs to be associated to a controller. So, we have to do ng-controller="controllerName" inside of out HTML (The controller which controls the view i.e supplies the model(data) etc..).
  ->  A template associated with a Route is generally considerd as a View and it is also controlled by the controller. 
  !!!!!
  ->  We can also create fields and associate values inside of the template itself(Inside " " where we generally write expressions). e.g ng-focus="isFocussed=true".
      This variable will only be accessible within the scope of the controller in the template in which it resides(Also, it cannot be accessed in the controller - JS code).
      These can be called as Template Only variables.

Dependency Injection:
  -> Rather than creating an object inside a function, we pass it(object) to the function.
  -> Angular does dependency injection by parsing the parameters of the methods. e.g angular.injector().annotate(myControllerFunction), gives all params to the myControllerFunction function 

Service:
  -> We can get any service by simply including them in the parameter list.
  -> Most Angular JS services are implemented as singleton with exceptions like $scope.
  -> A Service can be used to share data across controllers. i.e Maintain the state of the view.
  -> A factory is also similar to a service in Angular JS.
  Scope service:
    -> $scope is an Object from Scope service.
    -> This object is passed to the controller function and also the link function in directives.
    ***********
    -> This data becomes available inside of the view.
    -> This is a child scope inheriting from the root scope attached to the app module.
    -> This data($scope) is specific to the view attached to the controller. If we use the same controller again, then we will be having a different $scope.
    -> The $scope becomes the middle piece between the controller and the view.
  $log service:
    ->  Enhances the console.log and acts as a wrapper.
  $filter:
    ->  convert values. $filter('uppercase')(myField)
  $timeout:
    ->  wrapper over setTimeout. Keeps things angular way.
  $http:
    ->  wrapper for Making HTTP requests.
  $location:
    ->  It makes the URL available to our application.
  $routeParams:
    ->  Allows us to retrieve the current set of route parameters.
  $resource:
    ->  A factory which creates a resource object that lets you interact with RESTful server-side data sources.
    ->  The returned resource object has action methods which provide high-level behaviors without the need to interact with the low level $http service.
    ->  Fields will be just save, get etc. But, while using we have to do $get, $save
    ->  All methods accepts a callback as an argument, which can be passed to run code after the request is successful.
        Syntax:
        $resource(url, [paramDefaults], [actions], options);
          paramDefaults : params in the URL(Not query params). If this is part of the url, then need to add @ sign before it to tell $resource to extract it from the passed object.
                          e.g $resource('/api/things/:id', {id: '@id'}, {})
                          If the param value in url is not passed, then it will make request without it.
          actions       : extend the $resource object with additional functionalities. e.g add update method(PUT)   // {method:?, params:?, isArray:?, headers:?, ...}
        Available methods:
          query   - retrieve a collection from the server. Ignores the dynamic part(specific id from the request url)
          get     - GET request
          save    - POST request
          delete  - DELETE request

    $q:
      ->  This can be used to create custom promise object.(i.e wrapper for code that does not returns a promise)
          Usage:
          1.
            return $q(function (resolve, reject) {
              resolve(value) OR reject(value)
            })  
          2.
            let defer = $q.defer()
            defer.resolve(value) OR defer.reject(value)
            defer.promise
          3. $q.all([promises1, promises2])           // Array of promises
          4. $q.race([promises1, promises2])          // Array of promises. Resolves first one as soon as it is available.
          5. $q.resolve(value)                        // Resolve a promise
          6. $q.reject(value)                         // Reject a promise

  Custom Services:
    -> The custom service created will be a Singleton object.
    -> myApp.service("serviceService", function() { }). We can just use this.field inside of the function. All of those fields will be available on the service object.
    -> Using it in our controllers is same as injecting the in-built services in controllers(Dependency injection).
    -> We can inject other serivces into our custom service using the same way(Dependency injection) as we did for controllers.
    -> We can attach properties and method to our service using the `this` keyword.(i.e $scope is not available for services)

Factory:
  ->  Same as services except for the syntax.
      Syntax:
      myApp.factory("MyFactory", function() {
        return { }
      })
      The callback function returns the fields that are associated with factory object(we used `this` in case of services).

Directives:
  -> An instruction to Angular JS to manipulate a piece of the DOM(where it is attached).
  -> All params used in the directive's link method are dependency Injection params.
  ******
  -> ng-app and ng-controller are also Directives.
  -> All/most browser events have a corresponding directives in angular. e.g click(ng-click), keypress(ng-keypress) etc..
  Common directives:
    ng-model:
      ->  ng-model="myField".          // For two way data bindings.
      -> We can also do two way bindings of nested JS object fields.e.g ng-model="data.cost.amount"
      !!!!!!!
      ->  The field "myField" need not exist inside of the controller. In which case it will be a template only variable. 
          But, it will always have the latest input value(due to ng-model data binding). This can be used to use user input and do some processing like filter results etc..
      ->  If we were to use ng-model on a contenteditable element(New Feature) instead of the input element. We need to add a new Directive to that element that helps in mimicing the behaviour of ng-model.
          Inside of our custom directive, we need to require ngModel directive on the element. It has two useful methods - $setViewValue and $render
          The contenteditable fires an input event on the element, we we can listen to(subscribe) in Link method $element.on("input", function () {}).
          Inside of the input event callback, we can call ngModelCtrl.$setViewValue() to set the view value. Usually gets called when the input elem value changes
          We should do ngModel.$render = function() { $element.html(ngModel.$modelValue)}. This gets called when angular needs to update the view when the model value changes.
    ng-if:
      -> ng-if="JS expression"        // JS expression returning boolean value
      -> elem is completely removed from the DOM.

    ng-switch:
      -> ng-switch="field". Then inside it, ng-switch-when="string_value" or ng-switch-default.

    ng-hide/ng-show:
      -> ng-hide="JS expression"        // JS expression returning boolean value
      -> elem remains in DOM. Only hidden

    ng-class:
      -> ng-class="JSON Object" OR a string value(single class)         // For JSON class name and boolean value
      -> Need to enclose field names in 'fieldName', if it has - or _ in field names etc..

    ng-repeat:
      ->  ng-repeat="field in array".   // This not just repeats the elements/template within it, but also repeats the element on which it sits.
      ->  We can use $index to access index inside of the ng-repeat.
      ->  Inside of each ng-repeat, we can also do two way binding on each of the INDIVIDUAL input elements whose value correspond to an element in the collection.
          If the input value changes, its corresponding value at the array index also changes.

    ng-cloak:
      -> It hides the element untill angular JS has worked on it. To prevent showing things to the user without interpolated values(In case of slow internet).
    
    ng-src/hg-href
      -> If src="some_url/{{myVar}}". Used if src/href have interpolated values, we can use this to make request only after the values are populated.
    
    ng-submit:
      ->  Add ng-submit="mySubmitFunction()" to the form element itself.
      ->  It automatically does the event.preventDefault to prevent default form submission(default HTML behaviour).
      ->  The submit callback function is called with the current scope in which the form is residing.
    
    ng-change:
      ->  We can use this directive to listen to change events on a particular input(works on input element).
      ->  Can be used for autocomplete or validation as the user types.
    
    ng-disabled:
      ->  ng-disabled="boolean expression"

    ng-options:
      ->  ngRepeat can be used on <option> elements instead of ngOptions to achieve a similar result. However, ngOptions provides some benefits
          i.e When an item in the <select> menu is selected, the array element or object property represented by the selected option will be bound to the model identified by the ngModel directive.
      ->  Optionally, a single hard-coded <option> element, with the value set to an empty string(Empty string is important), can be nested into the <select> element. If this gets selected, the model value will be null.
      ->  Syntax:
          product.label for product in products

  Custom Directives:
    ->  Gives way to bring-in HTML reusable components in our HTML files(Template Directives).
    ->  Directives can also be used to change the behaviour of an HTML element(Behaviourial Directives)(i.e without any template changes)
    ->  In order to normalize between HTML and JS variable names. Angular JS converts/normailizes between them. i.e kebab case in HTML and camelCase in JS.
        Directive names should be in camel case. But should be used as kebab case inside of the template.
    ->  myApp.directive('searchResult', function() { return { }})          // This function returns the actual directive.
        Directive properties
          restrict:           // how we want to use this directive as(e.g as Attribute selector or element selector)
          scope: {}           // The scope within the directive template.
          bindToController:   // Bind the scope object dirtectly to the controller
          controller:         // Either a function or a string referring to a controller.
          template:           // HTML template
          templateUrl:        // relative location to template
          replace:            // boolean, whether we should keep the search-result tag or not in DOM(If yes, the template will be under it)
          compile:            // function
          link:               // function. Post link(see Link below)
          transclude:         // boolean. To allow Transclusion or not
    ->  By default, element selector and attribute of directive name(both behave as same) work for getting directives. We can configure it manually using the restrict field.
        A - Attribute
        E - Element
        C - Class
        M - Comment       <!-- directive: search-result -->
        We can use them as restrict: "AEC" OR "AE" OR "E" etc..
        Scope:
          ->  The directive can access the scope of the parent template by default. This can be problematic, since the directive can be re-used in many place and it should not depend upon the scope of its parent.
              Angular JS provides a method to Isolate the model($scope) part of the directive from the model of the parent page. This is called isolated scope.
              We can still access the data from the scope of the parent template inside of the directive, through custom attributes and normalization(i.e poking holes). 
              e.g person-name={{ person.name }} OR personObj="person" (Object itself)
              @ - Text. One way data binding. use {{ field }}                 // It is important that we use {{ }} in this case.
              = - Two way binding. For Objects and fields                     // should not use {{ }} even for field values
              & - To access parent scope function
              e.g scope = {
                personName: "@"             //  personNameSpecial: "@personName". Here, @personName comes from the attribute person-name.
              }
          ->  We can keep its value as either true or pass an Object with details about the type of bindings.
              If true specified, then a seperate scope is created for the child directive, and it also prottypically inherits from the parent scope.
              This also creates same problem as scope false, since the child scope is binded to parent unsing the two way binding(Prototypical inheritence)
              Notes:
                ->  The scope object should only have fields that we want to get from the parent scope/attributes.
                ->  If the scope object is not mentioned, then all the directives (inside of a parent controller) will only use the scope of the parent
                    (i.e no seperate scope for child) (i.e the child controller fields will be accessible in parent scope itself).
                    Even though the directive controller is called for each invokation of the directive. It all updates the single scope(which is the parent scope in this case).
                    If the Directive Controller is defined outside of the current parent controller(as a controller itself or inside another controller). Then that will not be affected due to this scope.
                ->  The scope object is NOT merged to the controller object by default(But it is available in $scope object inside of the controller and we can use it to merge the fields with controller object).
                ->  We can tell angular to automatically bind the scope Object(data from attributes) to controller object by renaming the scope object to bindToController.
                    But, we we still need to have scope object as {} in this case too for scope isolation.
        passing and using function:
              ->  my-function-attr="myParentFunction(param1, param2)"           // Here, the params name don't need to match up with the param names in the actual function in the parent scope. 
                  But, need to match when actualling calling them inside of the directives.
              ->  scope: { myFunctionInDirective: "&" }                         // making it available in directive scope
              ->  when using inside of the directive. myFunctionInDirective({ param1: "some_Value", param2: "some_value" }). This makes sure that we pass in the desired object we want to the function
                  Here, always the function args should be object having map of param names defined earlier and its values.
              ->  Important thing to note is that no matter how the function is called, it is binded to the scope in which it was originally created(i.e parent scope).
        bindToController:
          ->  We can either specify true(bind all fields) or explicitly specify which fields from the scope that we want to bind to.
              If fields are specified in JSON object, then we can remove the same in scope object(to remove duplicate code)
        Controller:
          ->  We can pass in what controller we want to use for the template in the Directive properties itself, instead of having it in the HTML template
              where we invoke the directive.
          ->  The model data in this case comes from two sources. 
                ->  Scope Object. i.e From the attributes on the directive element(where it is invoked). i.e getting data from parent scope.
                ->  Inside of the controller           // Normal

        Compile:
          ->  Do some processing on the directive template before our directive gets used.
          ->  This is called by angular before our directive is going to be used for the first time in our application. In case of second or third usages, this function is NOT executed.
          ->  This can be used to manipulate the HTML template of the directive.
          ->  If the compile function is used, then we cannot use the Link function along with with it.(i.e should return the PostLink function from compile function)
          ->  Syntax:
              function (elem, attr) {
                // code
                return {
                  pre: function(scope, element, attr) { // code }
                  post: function(scope, element, attr) { // code }
                }
              }
              Cycle:
                ->  Compiles a directive                            // Only once ever
                ->  Runs pre-link on the directive
                ->  Compiles the child directives                   // Only once ever
                ->  Runs pre-link on the child directive
                ->  Runs post-link on the child directive
                ->  Runs post-link on the parent directive
                ->  Then outputs the child and parent directive template to the user.
        Link:
          ->  This is run everytime a directive is used(unlike compile which is called once). 
          ->  We can do some pre and post processing on the directive template before our directive gets used.
          ->  It is better to use post-link(i.e avoid pre-link) as we have better control over all the elements.
          ->  This can be used when we want some logic to reside inside of the JS file like adding our own listeners(we have access to the scope object of this directive), or make decision based on some other values etc..
          !!!!!!!
          ->  This can also be used to add event native listeners on the HTML element.
        Transclusion:
          ->  Take a copy of one document and place it at a particulat point inside the other document.
              Single slot Transclusion:
                ->  By default any elements placed between the directive element is ignored(i.e Not inside the Directive template but the place where the directive is invoked).
                    We can ask Angular JS to include this by adding the <ng-transclude> element or ng-transclude as an attribute inside of the directive template.
                    This acts as a place holder for all the elements within the directive element(Place where directive is invoked).
                    Also, add the transclude property of the scope to be true.
              Transclusion by $transclude:
                ->  Inside of the link function($scope, $element, $attrs, $ctrl, $transclude), we have access to the transclude method. 
                ->  The transclude function when executed returns the HTML elements to be transcluded as an array(i.e HTML elements present where the directive is invoked).
                    We can use them to append it to the HTML template of the directive.
                ->  The transclude function also accepts an array which can be used to modify the HTML elements in the array before returning.
                    $transclude((elements) => { })
              Multi Slot Transclusion:
                ->  We can pass in an object to the transclude field and also assign a name to it.
                    {
                      name: "h1"          // h1 element to be transcluded,
                      desc: "?p"          // p element to be transcluded
                    }
                ->  Then inside of the directive template, we can do ng-transclude="name" OR ng-transclude="desc" as attributes.
                ->  We can also mention a field as option by putting a ? sign. In this case, if the value was not supplied, then the contents inside the HTML element
                    having attribute ng-transclude="optionalName" will be printed to the screen.
                    <span ng-transclude="desc">No Description</span>          // No Description will be printed if desc was not supplied.
        Require:
          ->  Require another directive and inject its controller as the fourth argument to the linking function.
              The require name will be that of the directive and injected thing will be the Controller instance of the directive($ctrl).
          ->  The require takes a string name (or array of strings) of the directive(s)(NOT ITS Controller) to require. If an array is used, the injected controller argument will be an array in corresponding order.
          ->  If no such directive can be found, or if the directive does not have a controller, then an error is raised.
          ->  The name can be prefixed with:
              (no prefix) - Locate the required controller on the current(same) element(multiple directives on one element).
              ^           - Locate the required controller by searching the element and its parents
              ^^          - Locate the required controller by searching the element's parents.
              ?^ OR ?^^   - Same as ^ or ^^, except that it will not throw an error if controller is not found. i.e null will be passed.

              Note:
                ->  parents in the context of the HTML template hierarchy.
                ->  This can be used to pass in data from the child to the parent directive. The Object will be the same in child and parent directive.
                ->  If we accessed $ctrl inside of the Link function of the directive without specifying the require field, then it corresponds to the Controller of the Current Directive(Its its own)



Interceptors:
  ->  We can intercept HTTP request and response and have some logic in it that may manipulate the request and response. e.g Add headers to request etc.
      Usage:
        ->  Create a factory MyInterceptor.i.e myApp.factory('MyInterceptor', MyInterceptor)
        ->  It can have functions like
            request(config)             // return config
            requestError(config)        // return config
            response(config)            // return response
            responseError(config)       // return response
        ->  Inject $q and do $q.reject(value) for requestError and responseError
        ->  myApp.config(function($httpProvider) {
              $httpProvider.interceptors.push('MyInterceptor')
            })


Data bindings:
  ->  One  way:
        Output data (from JS to HTML) i.e String Interpolation {{data}}. We can add any valid JS expression inside there.
        !!!!!!!
        Note:
          -> For Interpolation, even if we only call a function which internally uses the field which was changed. Angular will still call that method and get the updated value.
  ->  Two way data bindings. 
        -> ng-model directive
        -> This is only available for user input fields like <input>(text, checkbox(boolean)), <select> and also for element with contenteditable attribute(New feature in HTML 5) etc..
        -> Also available through '=' sign inside of Directives(Defining the type of binding for the directive scope).
        Parser and Formatter:
          ->  We can use this to control the model to view and view to model values.
          ->  require the ngModel directive inside of our custom directive(See Two way data binding for more info).
          ->  ngModelCtrl.$formatters has an array of methods. These gets run against our model values. They allow us to manipulate the value before it is returned to the view.
          ->  ngModelCtrl.$parsers has an array of methods. These gets run against our view values. They allow us to manipulate the value before it is stored to the model.

Digest Loop:
  ->  Everytime we put a variable or a function that is on the $scope and put it on the HTML page. Angular JS automatically adds a watcher for that variable in the watch list.
      i.e It keeps track of the old value and the new value, everytime something happens that might have changed the value. i.e when an event is trigger like click, keypress etc.. 
      It goes through every single variable in the watchlist to see it is changed(comparing the old value and new value). If a variable is changed, then it updates everywhere it is connected to.
      e.g DOM(Interpolation), in JS code. 
      This part of watching and checking for changes is inside the Digest loop. It is like the Event loop but specific to Angular JS.
      Then after that it runs one more cycle, to see if changing that variable, changed some other variable untill all of the old values and the new values match.

Watchers:
  ->  Everytime we put a variable or a function that is on the $scope and put it on the HTML page. Angular JS automatically adds a watcher for that variable in the watch list.
  ->  We can also manually add something(inside $scope) to the watch list. This can be done to attach a callback that executes when it changes.
      $scope.$watch("myField", function(newValue, oldValue) { })
      This is usually done inside of a Controller or a Link function inside of a Directive(i.e where we access to $scope).
  ->  We can also watch for changes in HTML attributes(we get access to them inside of the Directives link function - $attr).
      $scope.$watch($attr.todoAutofocus, function(newValue, oldValue) { })
  ->  Angular JS passes the old value and the new value to the callback function.
  ->  If we made changes outside of the Angular context like inside of setTimeout. Angular does not know that something has changed and also will not run the Digest loop
      to check for any changes to the variables in the watch list. 
      (i.e All code inside of the $watch should be wrapped inside of $scope.$apply to allow digest cycle to detect changes.)
      We can fix this using the $scope.$apply(myFunction). i.e after the code is run, Angular JS runs the digest cycle to check for any changes.
      OR 
      use the $timeout service.
  ->  The thing that connects the Model and the view is watchers and digest cycle.
  ->  If we use syntax of Controller As, then the first argument to $watch should be a function that returns the VALUE of the variable.(This says if it is changed when executed)
      e.g $scope.$watch(function() { return self.count }, function(newValue, oldValue) { })         // Binding `this`/using self is important here
  ->  For watching Deep Objects, we need to pass in a third argument with value as true.
  ->  We can use $scope.$watchCollection(function() { return self.count }, function(newValue, oldValue) { }) (without third param as in above). This triggers change event when an item is added or deleted to the collection.
      Also, this does not do deep checking for changes only top level check.

Atribute($attrs) methods:
  $observe:
    ->  This can be used for observing changes to a specific attribute. This doesn't set up a watcher for the attribute. This makes our application slightly faster.
    ->  They only work on attributes with interpolated values.
    ->  This can be done inside of the Link function of the directive.(We have access to $attrs variable there)
        Syntax:
        $attrs.$observe("myAttribute", function(value) { })
  
  $updateClass:
    ->  This is used to update the class of the element on which the attribute sits.
        Syntax:
        $attrs.$updateClass("old-class", "class-to-replace")

  Notes:
    -> We can look into all the supported $attrs function and fields by looking into $attrs.__proto__ variable

Routing:
  ->  This is handled in the module angular-route.js. Need to include this in the app module dependencies array.
  ->  Configuring routes:
        myApp.config(function($routeProvider, $urlRouterProvider) {
          $routeProvider.when("/", {
            templateUrl: "path_",
            controller: "myController"
          })      
        })
  ->  To add query params add /:id/page. Can be retrieved using $routeParams service.
  ->  Add the directive ng-view to a div element.
  ->  The template associated with the route is considered as a View.
  ->  Through code, we can navigate to a different route using the location service, $location.path('/my-path')
  ->  We can do urlRouterProvider.otherwise("/") inside .config callback for directing to home route in case we could not find any other matching route.
      Routing Using ui-router:
        -> Add the ui-router module dependency to app module.
        ->  Inside of .config callback
            $stateProvider.state('myState', {
              url: "/",
              controller: "",
              template: ""
            })
        ->  Add the <ui-view> or <div ui-view> for the route placeholder
        Navigation:
          There are three main ways to activate a state:
            ->  Call $state.go(). High-level convenience method.
            ->  Click a link containing the ui-sref directive.e.g ui-sref="stateName"
            ->  Navigate to the url associated with the state.
        URL Parameters:
          ->  '/hello/' - exactly match
          ->  '/user/:id' - Matches '/user/bob' 
          ->  '/user/{id}' - Same as the previous example, but using curly brace syntax.
          ->  '/user/{id:int}' - The param is interpreted as Integer.
        Router properties:
          url:                      //  URL to load this resource
          controller:               //  Controller of the View. Not preffered, use Components
          template:                 //  Template of the View. Not preffered, use Components
          component:                //  Component name
          redirectTo:               //  Value is another state name. e.g for nested states parent.child
          resolve:  {}              //  Object.
          data: {}                  //  Custon data properties
          params: {}                //  Query param object
          views:  {}                //  Defining views
          resolve:
            ->  Each field in this object has a promise which resolves to some value. We can get access to that RESOLVED value in our template by using binding field inside of the component.
                Here, binding is not from the template(like in normal cases. i.e binding fields from parent component). The binding is between the routing and the component.
        Nested Routes:
          ->  These have parent-child relationship.i.e Parent state properties are available to use in all the child states.
              Creation:
                Using .(Dot) notation in child's state name. e,g $stateProvider.state('parent.child', {})
                Using the parent: "parentStateName" while configuring. e.g $stateProvider.state('child', { parent: "parent" })
          ->  This forms a hierarchy of states(Nested within each other). The loading can be viewed as a hierarchy of <ui-view>.
              First the index.html is loaded(default). Then the first state in the hierarchy(Parent) gets loaded in the <ui-view> inside of the Main View(index.html)
              Then the loaded parent template should be having a <ui-view> inside of which the child state gets loaded and so on.
              The point to note here is that if ant any point there was no <ui-view> to load the scope(e.g no <ui-view> in index.html), then the hierarchy is cut-off and only the currently loaded ones remain.
          ->  We can add ^ before the url to tell UI router to ignore the parent URL path completely and only consider the given path. .eg "^/phone"
          ->  When a state is "active", all of its ancestor states are implicitly active as well. Below, when the "contacts.list" state is active, the "contacts" state is implicitly active as well,
              because it's the parent state to "contacts.list".
        Multiple Views:
          ->  We can have multiple views inside of a single view(template). 
          ->  Remove the component field inside of route config for the state(which will host multiple views)and replace it with views.
              e.g views: {
                "@": {                                // default view
                  component: "myComponent"
                },
                "methods@contact": {                         // value before @ sign is the name of the view and value after @ is the state within which this inner view is present(i.e the same state name in which this config is made)
                  component: "innerViewComponent"
                }
              }
          ->  Add ui-view="viewName" (here ui-view is attribute instead of an element)
          ->  Adding the views config for a component can be done anywhere. But, the thing to note is that, there is going to be only one url loaded at a time.
              So, if a view is associated with an url, then we can define the view in its own component declaration file(i.e where the state is also declared). 
              But, if the view only has a template and not any url associated. Then it makes sense to define the view config in the parent component itself.
              Since this component will otherwise never gets loaded.
          ->  Also, there can be multiple views with the same name and parent state name. The right view will be selected based on the url.
        Data inheritence:
          ->  Child states will inherit resolved dependencies from parent state(s), which they can overwrite. we can access it in $scope of the controller
          ->  Custom data properties
        Notes:
          -> We can't have two different states named "edit" even if they have different parents.
           
  


Filters/Pipes:
  ->  We can use this to manipulate data. Can be used in both JS and HTML expression.
  ->  Inside HTML expression, we can pass in attributes to the filter using | my_filter:"value1":"value2" etc..
  ->  The argument passed can be anything e.g a variable(Both template Only and Modal value(i.e data form controller)), strings, arrays, objects etc..
  ->  We can also chain filters one after the other. e.g data | filter1:arg1 | filter2:arg1
      Syntax:
      {{ myCurrency | currency:'$':1 }}
      Inbuilt Filters/Pipes:
        date
        currency
        orderBy:
          -> orderBy: 'year'   OR  orderBy: '-year'(descending order) OR  orderBy: 'year': true (descending order)       // Here year is the field of an object inside the array we want to order
          -> The field can be dynamic.
        filter: 
          ->  Can be used for filtering results from a list.
          ->  filter: { year: value }                 // searches for year field
          ->  filter: value                           // searches for all fields
        json:                                         // pretiffy JSON data in DOM
      
      Custom Filters:
        ->  This allows us to pass in some data and return a new value based on its functionality.
        ->  myApp.filter("filterName", function() { 
              return function (value, arg1) { }
            })

Forms:
  ->  Most of the forma state and also validation states are persisted in the element class attribute by angular. e.g class="ng-valid ng-pristine ng-touched"
  Validation:
    ->  To include angular JS form validation, we need to include the name attribute on the top level form and also the input fields that will have validation.
    ->  By doing above gives access to angular's form object which has various details about the form.(e.g isValid, isTouched). This can be accessed using the name attribute on the form element.
        e.g <form name="myForm"> </form>
        // myForm.isValid etc..
    ->  We can add our own custom validation using ngModelCtrl.$validation.myErrorField = function(modelValue, viewValue) { // reurn BOOLEAN_EXPRESSION }     // ngModelCtrl is required using require field in our directive($ctrl)
        We can then access myErrorField using formName.fieldName.$error.myErrorField to see if has true value.
        NgMessages:
          ->  We can use ng-message module to display easy error messages for our form.
              It allows us to group all errors of a particular element together.
              e.g <div ng-messages="formName.fieldName.$error"> 
                    <div ng-message="required"> Blaw </div> <div ng-message="minlength"> Blaw </div>
                  </div>
              Note:
                ->  Both parent and child element have same directive name - ng-messages
          ->  We can display multiple error messages for ng-message by adding the directive ng-messages-multiple.
          ->  We can also include the template for error messges(Same HTML template with ng-messages directive added by referenced from a script tag or an external file).
              Using Script tag:
              <script type="text/ng-template" id="generic-message-template.html">
                <div ng-message="required"> Blaw </div> <div ng-message="minlength"> Blaw </div>
              </script>
              And inside of the ng-messages template(parent template), we can just do ng-messages-include="generic-message-template.html"
              If we also had an element with same error as in the template, then that element error message will take precedence over the template error message.
              i.e child ng-messgaes and ng-messages-include(template) both have ng-messages="required" added to it.
          ->  We can also add messages dynamically, using the ng-repeat and the ng-messages-exp="singleErrorInArrar.type" and its text, using {{ singleErrorInArrar.text }}
          ->  We can also do ng-messages-exp="['minlength', 'maxlength']" to use same error message for multiple errors.

Publish and subscribe events:
  Using $scope:
    ->  Inside of the controller, we can use the $scope to emit a custom event. e.g $scope.$emit("login", {})
        $emit needs to be used when we want to fire an event upward and $broadcast if we want to fire an event down the scope. Both are just the same.
    ->  We can also listen to custom events using $scope.$on("login", function(event, data) {}). Both upward and downward.
    ->  The drawback with this approach is, the order/place of the scope is important. i.e when there are two parallel scopes without parent-child hierarchy then it is a problem
  Using $rootScope:
    ->  $rootscope is the first scope that is created when we angular bootstraps our application.
    ->  All further scope instances either inherit from the $rootScope or have an isolated scope with a directive or a component. 
    ->  $rootScope can be used to publish events application wide(unlike $scope which looks at the hierarchy of the components).
    ->  We can listen to event on the $rootScope(same way as $scope). But in this case, we MUST manually un-subscribe the $rootScope from the event when the
        Component is destroyed because the $rootScope is persistent across the application unlike $scope which is destroyed automatically by angular when the component dies
        (i.e in $scope.on("$destroy", rootScopeName))
    ->  Any event broadcasted from $rootScope, $scope can actually listen to it too.(i.e Both $rootScope and $scope can listen if event broadcasted by $rootScope)
        This behaviour can be changed if we use $rootScope.emit() instead of $rootScope.broadcast()

Constants:
  ->  We can register constants in our angular app.
  ->  It should be readonly. i.e value should not be changed in our application
      Syntax
      angular.module("myModule").constant("MY_CONSTANT", value)      // value can be a string or an Object.
      We can then put it as a param in our controller method. It will be injected just like any other service by angular.
  
Values:
  ->  We can have mutuable values in our angular app.
      Syntax:
      angular.module("myModule").value("My_Value", value)      // value can be a string or an Object or also a function.
      We can then put it as a param in our controller method. It will be injected just like any other service by angular.

Testing:
  ->  Karma is a JavaScript command line tool that can be used to spawn a web server
      which loads our application's source code and executes our tests.
  ->  Jasmine is a behavior driven development framework for JavaScript.


  Setting Up
    ->  Need to add the following dependencies
        ["jasmine-core", "karma", "karma-chrome-launcher", "karma-jasmine", "karma-spec-reporter"]
    ->  run - karma init
    ->  Add plugins to karma.config file
        plugins: [
          require('karma-chrome-launcher'),
          require('karma-jasmine'),
          require('karma-spec-reporter'),
        ]
    ->  add the file pattern to files array. e.g 'tests/*.spec.js'
    ->  karma start
    Testing Controller:
      ->  add the following file pattern to files array in karma config. 
          [ 'js/angular.js', 'tests/angular-mocks.js', 'js/**/*.js', 'tests/*.spec.js' ]
      ->  beforeEach(module('app'))                   // instantiate/Loads the module
      ->  beforeEach(inject(function($injector) {
            // $injector - fetches dependencies from our application
            var $controller = $injector.get('$controller')      // YES, $controller is a service. Needed to inject our service
            var myController = $controller(MyController as myCont, {
              $scope: {},
              DependentService: MockedDependentService        // just a function object mocking the DependentService
            });
          }))
    Testing Directive Controller:
      ->  Step 1 and 2 same as above.
      ->  beforeEach(inject(function($injector) {
            // See Api reference for all function and its return value - https://docs.angularjs.org/api/ng/function/angular.element
            var $compile = $injector.get('$compile')            // $compile - Compiles an HTML string or DOM into a template and produces a template function, which can then be used to link scope and the template together.
            element = angular.element("<counter></counter>")    // Wraps a raw DOM element or HTML string as a jQuery element.
            $compile(element)($rootScope.new())                 // see above comments
            var $rootScope = $injector.get('$rootScope')        // $rootScope.new() creates a new $rootScope for us.
            var $controller = $injector.get('$controller')      
                                                                
            $controller = element.controller('counter')         // the controller for this directive(passed as args) will be retrieved 
            var $scope = element.isolateScope() || element.scope()    // Returns the isolated scope of the element
            Then call controller methods using $controller.myFunction()
          }))
    Testing Component Controller:
      ->  Step 1 and 2 same as first.
      ->  beforeEach(inject(function($injector) {
            // See Api reference for all function and its return value - https://docs.angularjs.org/api/ng/function/angular.element
            var $componentContoller = $injector.get('$componentContoller')            
            var controller = $componentContoller('compName', { $scope: {}, { initialCount: initialCount }})       // Here, the third args is the bindings object(i.e data from parent inside of template etc..)
          }))
      ->  For testing life cycle hooks, we need to actually call the hook(e.g controller.$onInit() etc..), since, we dont have the actual DOM, in which case this is automatically called by the angularjs itself.
    Testing Filters:
      ->  Step 1 and 2 same as first.
      ->  beforeEach(inject(function($injector) {
            // See Api reference for all function and its return value - https://docs.angularjs.org/api/ng/function/angular.element
            var $filter = $injector.get('$filter')            
            var filter = $filter('filterName');
            execute the filter using filter(value, arg1, arg2)
          }))
    Testing Service:
      ->  Step 1 and 2 same as first.
      ->  beforeEach(inject(function($injector) {
            // See Api reference for all function and its return value - https://docs.angularjs.org/api/ng/function/angular.element
            var myCustomService = $injector.get('$myCustomService')            
            var $httpBackend = $filter('$httpBackend');           // for mocing requests
            $httpBackend.when('url').respond({})
          }))
      ->  We can also test the api getting fired using $httpBackend.expectGet('url')
      ->  Need to call done when our tests are over(since async - just like mocha)
      ->  $httpBackend.flush() in the end.
    Testing Routing:
      ->  Step 1 and 2 same as first.
      ->  beforeEach(inject(function($injector) {
            // See Api reference for all function and its return value - https://docs.angularjs.org/api/ng/function/angular.element
            var $state = $injector.get('$state')
            var $http = $injector.get('$http')                                    // Here, $http is only inject because the user function in resolve object expects it. Not needed otherwise
            var $httpBackend = $injector.get('$httpBackend')
            $httpBackend.when('url').respond({})                                  // Need to ALSO STUB the TEMPLATE URL, because it is also loaded by angular
          }))
      ->  Here, myState has all the properties of the state declaration.
      ->  myState.resolve.user($http, {}).then(function() {})                                // Here, use is one property in resolve object
      ->  We can also test the api getting fired using $httpBackend.expectGet('url')
      ->  $httpBackend.flush() in the end.
      