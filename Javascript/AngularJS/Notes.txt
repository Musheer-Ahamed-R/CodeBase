1 ->  Composed of 
        -> Modules
        -> Components
        -> Directives
        -> Services
        -> Routing + Views
        -> Controllers

2 -> Good practice to add new directives in a new line of the HTML element.
3 -> We can also add new fields inside of the template. We can access that within our template. We cannot access that in our Controller.
4 -> Business logic should be present in services.
5 -> Anything we plan on using, wither Controller or Directives, we need to includ ethe src="" at the end to be able to access them in our template.
6 -> we can use json filter for debugging purposes.
7 -> We can use angular.module('app').config(function () {})     // This config method allows us to run logic when angular loads.

Modules:
  -> Code consisting of Routes, Views, Components or Services
  -> Feature should more likely be a Modules

Routing;
  -> Controls the navigation for the user and creats a Controller and Views 


  -> Controllers are responsible for View logic and exposing properties for view binding
  -> View to controller - date is binded through Scope object
  -> Views are bigger Components(Can have multiple Components)
  -> Components can also have a controller. Declaring new template and binding data.


Creating modules:
  -> Create a module
      angular
        .module('app', [])      // array of dependencies if any, need to pass even if no dependencies
  -> loading module, add ng-app="app" as an HTMl attribute

Creating controller:
  -> Managing Views and Controllers
  -> angular
      .module('app')      // don't pass the second arg. That means creating a new module
      .controller('MyFunctionName', MyFunctionName)
  -> loading controller, add ng-controller="MyFunctionName" as an HTMl attribute.
  -> Inside it we can access the properties
  -> $scope inside of that function
  -> MyFunctionName.$inject = ["$scope", "$rootScope"]        // This is minification safe.
     This can also be passed during the controller declaration
  -> Using Controller as Alias, we can create instance of that controller(Plain JS Object). Need to access as alias.name.
     Also, can get rid of the dependency injection($scope) and just use this. inside of the Controller function.


Creating Services:
  -> angular
      .module('app')      // don't pass the second arg. That means creating a new module
      .service("ServiceName", Service)
  -> Any service we created in Angular's Dependency injection system.
  -> We can also .factory(). This will return the fields that can be accessed by outside code. Otherwise, all fields we assisned using this inside of the Service
     method will be accessible to all. It is just a matter of preference.

Dependency Injection:
  -> Dependency injection is very simple. Just use the field in method param and it will be injected automatically.


Directives:
  -> angular
      .module('app')      // don't pass the second arg. That means creating a new module
      .directive("myDirective", Directive);
  -> Directive names should be in camel case. But should be used as kebab case inside of the template.
  -> Behaviourial directives and template directives
  -> Can use Directive to chunk out some common functionalites. We can define which controller the directive belongs to and also its template.
  -> Need to pass scope otherwise changes will be reflected globally.
  -> The fields inside of the scope can be used to bind values from outside. e.g scope: {
      count: "="  // actually says "=count" since name and bind field are same. Also, = means two way bindings.
    }
  -> we can say bindToController instead of scope, to be able to bind to the this value inside of the controller. This will avoid using $scope inside of the controlller
     i.e Here $scope has the value we obtained through binding from template(Directive). The date is then passed from directive to the controller using $scope.
     Still need to keep scope as {}.
     Since two way binding, the values changed in the controller of the directive is also reflected inside of parent controller.
  -> We can do field: "@"   // to make it as read only. Then, inside of the template, we have to do field="{{ }}" (i.e like string interpolation)
     otherwise if two way binding, we have to do field="parentField"      // without string interpolation
  -> link function has ($scope, element, attrs) for a directive. (Behaviourial directives)
  -> scope: false inherits the scope of the current context.
  -> We can use .$watch to watch for changes to a certain field. e.g $scope.$watch('fieldName', callBack)
     Also, any new event we execute like .focus etc should be done inside of a setTimeout. i.e It has to be pushed to the end of the call stack. (The way angular works)
  -> We can also pass in an entire object from the parent controller to the directive and that too with two way data bindings.
  -> To deligate functions to our directive from our component, we can do field="myFunction()" and inside of the directive.bindToController, field: "&"   // Yes. actually use ()


ng-repeat:
  -> add ng-repeat="movie in movies.favourites" attribute
  -> We can use $index to access index inside of the ng-repeat

ng-hide/ng-show:
  -> add ng-hide="truthy/falsy expression" attribute
  -> elem remains in DOM. Only hidden

ng-if:
  -> add ng-if="truthy/falsy expression" attribute
  -> elem is not in DOM

ng-switch:
  -> add ng-switch="" attribute. Then ng-switch-when="value" or ng-switch-default attribute.

ng-class:
  -> 

ng-model:
  -> Two way data binding         // This is on input fields

ng-src/hg-href
  -> If sec/href attributes have dynamci values, we can use these.

ng-click:

ng-submit:

ng-blur/ng-focus:

ng-change:

ng-options

ng-disabled


Validators:
  -> create name attribue on top level form. and also create name obj for all input

Routing:
  -> Inside of the app.js (module), add the ui-router for adding routing dependency
  -> angular.module('app').config(function($stateProvider, $urlRouterProvider) {
     })
  -> For creating routes, we simply bind to the route provider object.
     $stateProvider.state('home', {
       url: "/",
       controller: "",
       template: ""
     })

Views:
  -> element <ui-view></ui-view>
  -> inside of code, for an <a> element, we can use ui-sref="home"

Filters:
  -> date
  -> currency
  -> orderBy
  -> filter - 
      - filter: { year: value } (searches for year field)
      - filter: value (searches for all fields)
  -> json         // pretiffy values