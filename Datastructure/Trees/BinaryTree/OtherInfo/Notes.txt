Important Points

1 -> Don't use root.getLChild() or root.getRChild() for NULL check(unless entirely necessary). It causes a lot of trouble with null pointer exception

2 -> The Order in which Left and the Right Child are added is extremely important(e.g, Iterative PreOrderTraversal, tree to doubly linked list)

******
3 -> For EACH AND EVERY TREE Problem, find if it can be solved using BFS or DFS(or Both)(RECURSIVE AND ITERATIVE). From that use the best approach.

4 -> If the word MINIMUM is used, then consider using BFS first.

5 -> When dealing with recursion, ALWAYS KNOW THAT THE METHODS ARE GOING TO BE EXECUTED and that methid call same ""FIRST"" method again and again 
     untill the base case is reached, thus the second method call will have to wait till that. THIS causes problems because of LESS understanding of the method call execution.(e.g see not working method - Perfect Binary Tree Specific Level Order Traversal).

3 -> Traversal Findings
           PreOrder Traversal :
                1 -> A Node will always have its left child after it.

          InOrder Traversal :
                1 -> flattens the Tree.(used in converting Tree to a Linked List)
                2 -> gives Nodes in increasing order if the tree is a BinarySearch Tree
                3 -> for a particular node, its left and right children are on its left and right respectively.(used in constructing a tree, if another traversal is given)
                4 -> The Successor of a Node is
                              1 -> The Right Child or the Left Most Child in the Right SubTree of the Current Node(Top to Bottom - Presence of Right Child)
                              2 -> The First Ancestor Node for which the current node is in the Left SubTree of that Node(Bottom to Top - Absence of a Right Child)
                5 -> The predecessor of a Node is
                              1 -> The Left Child or the Right Most Node in the Left Subtree of the Current Node(Top to Bottom - Presence of a Left Child)
                              2 -> The First Ancestor Node for which the Current Node is in the Right SubTree of that Node(Bottom to Top - Absence of a Left Child)

          PostOrder Traversal
                1 -> A Node will always have its right child before it.(used in case of Iterative Traversal)


4 -> The return value(Base Case) in a recursive call has a MAJOR MAJOR impact in the problem solution.(i.e They should be used wisely)

5 -> Using root instead of the Current Node can lead to UNNECESSARY TROUBLE. Always take care of this BIG careless mistake.

6 -> Traversals Quick Note (Iterative):
          -> PreOrderTraversal  - 2
          -> InOrderTraversal   - 3
          -> PostOrderTraversal - 3

          Relationships - 
              -> PreOrder and InOrder     -> Morris travsersal
              -> PreOrder and PostOrder   -> Level Order Traversal(In case of PostOrder Traversal, we have to Print in Reverse Order(Opposite of Normal Case)).
              -> InOrder and PostOrder    -> "Current Pointer is always before".(In postorder Traversel, the Current Node Stays null in First part of Second case)).
                                             Visited Map.     (We Keep on going LEFT till we reach the End. From there we start Processing).(NOT IDEAL)

7 -> While dealing with any of the traversals(Known or Unknown), WRITE DOWN the Traversal before making ANY MOVE.

8 -> Incase of Level Order Traversel - Level Printing, Consider doing operations(e.g adding to stack) while REMOVING Node rather than while adding.

9 -> Incase of Level Order Traversel, we can also keep track of the current level of the node by having another queue adjacent of it that holds the level.
     e.g Find next right node of a given key. Here, we get the level of target node and put the level for children as level + 1.

9 -> If we are dealing with a tree which has some Property, try to take ADVANTAGE OF THAT PROPERTY.(Sum Tree)

*****
10 -> Level Order Traversal and other such things that uses level order Traversal(Print Vertical View) can also be done using Preoder order traversal
      (Traversing for each level). But, this happens at O(n^2).

*****
11 - > The above method involves calculating height and traversing for each level(O(n^2)). REMEMBER THIS CAN SAVE A DAY, especially when space complexity
       is to be optimized.

11 -> When we want to know if there exists a value(or sum) equal to the given no or while wanting to reach a specific level, CONSIDER DECREMENTING the 
      value untill it reaches 0. (e.g RootToLeafSum, Level Order Printing using recusrsion).

12 -> Instead of appending the number, we can multiply the by no by 10 each time before adding the value(e.g Sum of all the numbers that are formed from
      root to leaf paths)